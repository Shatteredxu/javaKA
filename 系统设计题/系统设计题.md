### 回答套路

> Step1:问清楚系统具体要求(功能性需求：需要哪些功能；非功能：数据量，访问量，需要达到的QPS)
>
> Step2:进行抽象设计:考虑使用那些组件，
>
> Step3:考虑需要优化的点：会遇到哪些问题，怎么解决，（安全问题，分布式问题，高可用问题，分库分表，索引）
>
> 

##### 1.设计一个数据结构获取一个有上亿用户的游戏中玩家分数排名前一万的用户信息，以及获取排名一万以后任意用户的排名区间，不能借助类似redis的中间件，假设数据结构就在内存中

> 1.回答Redis的zset的实现：字典（hash，o(1)时间复杂度查找成员的分值）+跳跃表（排序找到区间分数）
>
> 2.第一个需求通过一个小顶堆来存储 Top 1W，每次有数据变动时和堆顶比较大小，如果大于堆顶则移除堆顶元素并且插入。如果要按序输出则堆排序即可。
>
> 第二个需求通过两个哈希表来实现。第一个哈希表存储 user_id 和分数的映射，第二个哈希表存储分数区间 到 user_id 集合（这个集合也是哈希表，在更改的时候效率高）， 这样可以根据 user_id 查找排名区间（先找到分数，然后找到分数区间，然后找到前面分数区间总人数，都是 O1 的复杂度）。如果 user_id 区间改动，则改一下哈希表的数据即可。

##### 2.设计一个微信朋友圈，你会怎么进行存储选型

> feed流扩散写扩散,

#### 3.如何设计一个**高并发**的系统，结合缓存，分库分表说的

##### **高性能架构设计**：响应时间

度量指标:平均，最大，分位值；

>   1.   提高核心数，增加系统并行度
>2.   CPU密集，IO密集，固态硬盘或者更好的CPU,做好系统监控
>   3.   异步
>4.   高性能的线程模型，放弃PPC(一个请求对应一个进程)和TPC(一个请求对应一个线程)，使用**Reactor 模式（**IO多路复用，一个进程处理多个连接，并且只有当有数据的时候才会去读数据）**异步网络模型 Proactor**(你先去忙，来数据了我通知你，能够**充分利用 DMA 特性**，让 I/O 操作与计算重叠，但要实现真正的异步 I/O，操作系统需要做大量的工作。目前 **Windows 下通过 IOCP 实现了真正的异步 I/O**，而在 Linux 系统下的 AIO 并不完善)
>   5.   还有就是对linux系统，对网络，对算法的优化。

##### **高可用架构设计** ：减少请求，down机，故障，维护，自动上线

**指标：****MTBF平均故障间隔 和 MTTR**故障的平均恢复时间 `Availability = MTBF / (MTBF + MTTR)`计算出一个比例代表系统可用性

1.   做好容错

     >   备份, 心跳，故障转移(集群主从复制)，分布式一致性Raft,Paxos ，超时控制，流量降级(排队削峰)，限流，熔断

2.   做好系统运维

     >   1.   故障演练和系统测试
     >
     >        通过在线上系统上**随机地关闭线上节点来模拟故障**，通过使用线上流量测试已存在的系统，压测
     >
     >   2.   灰度发布
     >
     >        除了灰度发布，还有其它发布方式

  3.    缓存

        >   Redis

##### **高扩展架构设计** ：(就是构建分布式系统)

说白了就是懂得**如何拆分系统**。你按照不同的思路来拆分软件系统，就会得到不同的架构。数据库、缓存、依赖的第三方、负载均衡、交换机带宽等等

1.   存储的扩展

     >   **数据库分库分表:** 池化技术，主从分离(主从同步问题，延迟问题)，分库分表(垂直拆分,水平拆分,拆分带来的问题)，全局唯一id问题，Nosql
     >
     >   **Redis缓存(分布式缓存)：**为什么用Redis，缓存高可用(哨兵和分片)，缓存数据和数据库一致性问题，缓存失效，Redis穿透，雪崩，静态资源缓存(CDN)

2.   业务的扩展

     >   业务纬度，重要性纬度和请求来源纬度。
     >
     >   由业务层面衍生出来的一系列分布式问题：分布式理论(CAP和BASE, 一致性),分布式事务(2PC, 3PC等六种解决方案), 分布式锁(Redis,数据库，zookeeper), 分布式服务(RPC的功能)，分布式消息(保证高性能，保证高可用，不被重复消费)，分布式Session

##### 4.设计短链接

**1.hash,**但是可能存在hash碰撞的问题，所以可以考虑采用布隆过滤器，查询Hash是否存在，如果存在则天上一个特殊字符来区分

**2.发号器：**

**请求方式：**

301，代表**永久重定向**。也就是说，浏览器第一次请求拿到重定向地址后，以后的请求，都是直接从浏览器缓存中获取重定向地址，不会再请求短链服务。这样可以有效减少服务请求数，降低服务器负载，但是因为后续浏览器不再向后端发送请求，因此获取不到真实的点击数。

302，代表**临时重定向**。也就是说，每次浏览器都会向服务器发起请求获取新的地址，虽然会给服务器增加压力，但在硬件过剩的今天，这点压力比起数据简直不值一提。所以，302 重定向才是短链服务的首选。

##### 5.设计一个延时队列

https://segmentfault.com/a/1190000022718540

##### 秒杀系统设计

### 14. 秒杀系统

遇到的问题：

**静态资源缓存+CDN**来缓解服务器获取资源的压力

**动态URL**,在秒杀开始时请求下发一个动态URL来防止脚本提前获取URL

**Redis先查询库存是否足够**，在访问数据库进行库存

分布式锁，只允许一个用户进行库存

使用延迟队列，延时取消不付款的用户订单

基于Redis限流，如果一个用户一个IP一直访问，则直接返回失败

加验证码

**缓存雪崩**，**缓存击穿**，**缓存穿透**

**我们在开发程序的时候都要有一颗“不信任”的心，就是不要相信任何调用方，比如你提供了API接口出去，你有这几个参数，那我觉得作为被调用方，任何可能的参数情况都应该被考虑到，做校验，因为你不相信调用你的人，你不知道他会传什么参数给你**

> <u>缓存雪崩(大面积的缓存失效):</u>redis中的key值在某一个时间段，全部过期后某一时刻流量剧增，缓存全部失效，请求全部打到数据库上，数据块直接挂掉，解决方案1.给每个键设置一个随机的过期时间2. 如果**Redis**是集群部署，将热点数据均匀分布在不同的**Redis**库中也能避免全部失效的问题,者设置热点数据永远不过期，有更新操作就更新缓存就
>
> <u>缓存穿透</u>:一直访问redis和数据库中都不存在的数据，如果后端没有做参数校验，在大量并发访问的情况下可能导致宕机，*解决方案：1. 接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，2. 对单个IP每秒访问次数超出阈值的IP都拉黑；3.布隆过滤器判断key是否存在 4.系统高可用做好*
>
> <u>缓存击穿（某个key突然失效）</u>：是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。解决方案：设置热点数据永远不过期
>
> * 事前：**Redis** 高可用，主从+哨兵，**Redis cluster**，避免全盘崩溃。
>
> * 事中：本地 **ehcache** 缓存 + **Hystrix** 限流+降级，避免** MySQL** 被打死。
> * 事后：**Redis** 持久化 **RDB**+**AOF**，一旦重启，自动从磁盘上加载数据*，快速恢复缓存数据。*

