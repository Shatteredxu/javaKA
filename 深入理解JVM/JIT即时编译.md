JIT即时编译
-----------

### 分层编译

HotSpot 虚拟机包含多个即时编译器 **C1、C2 和 Graal**，Graal 是一个实验性质的即时编译器，可以通过参数 -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler 启用，并且替换 C2。

对启动性能有要求的程序，我们采用编译效率较快的 C1，对应参数 -client。对于执行时间较长的，或者对峰值性能有要求的程序，我们采用生成代码执行效率较快的 C2，对应参数 -server。

<u>profiling 是指在程序执行过程中，收集能够反映程序执行状态的数据。这里所收集的数据我们称之为程序的 profile。</u>

分层编译将 Java 虚拟机的执行状态分为了五个层次。五个层级分别是：

1.  解释执行；
2.  执行不带 profiling 的 C1 代码；
3.  执行仅<u>带方法调用次数</u>以及<u>循环回边执行次数</u> profiling 的 C1 代码；
4.  执行带所有 profiling 的 C1 代码；
5.  执行 C2 代码。

>   1.   热点方法会被 3 层的 C1 编译，然后再被 4 层的 C2 编译。
>   2.   如果方法的字节码数目比较少（如 getter/setter），而且 3 层的 profiling 没有可收集的数据。
>   3.   Java 虚拟机断定该方法对于 C1 代码和 C2 代码的执行效率相同。在这种情况下，Java 虚拟机会在 3 层编译之后，直接选择用 1 层的 C1 编译。由于这是一个终止状态，因此 Java 虚拟机不会继续用 4 层的 C2 编译。
>   4.   在 C1 忙碌的情况下，Java 虚拟机在解释执行过程中对程序进行 profiling，而后直接由 4 层的 C2 编译。在 C2 忙碌的情况下，方法会被 2 层的 C1 编译，然后再被 3 层的 C1 编译，以减少方法在 3 层的执行时间。

### 即时编译的触发

Java 虚拟机是根据方法的调用次数以及循环回边的执行次数来触发即时编译的。

在不启用分层编译的情况下，当方法的调用次数和循环回边的次数的和，超过由参数 `-XX:CompileThreshold` 指定的阈值时（使用 C1 时，该值为 1500；使用 C2 时，该值为 10000），便会触发即时编译。

当启用分层编译时，Java 虚拟机将不再采用由参数 -XX:CompileThreshold 指定的阈值（该参数失效），而是使用另一套阈值系统。在这套系统中，阈值的大小是动态调整的。

### OSR 编译

除了以方法为单位的即时编译之外，Java 虚拟机还存在着另一种以循环为单位的即时编译，叫做 On-Stack-Replacement（OSR）编译。循环回边计数器便是用来触发这种类型的编译的。

OSR 指的是在程序执行过程中，<u>动态地替换掉 Java 方法栈桢</u>，从而使得程序能够在非方法入口处进行解释执行和编译后的代码之间的切换。事实上，去优化（deoptimization）采用的技术也可以称之为 OSR。

### Profiling

profiling，收集能够反映程序执行状态的数据。其中，最为基础的便是方法的调用次数以及循环回边的执行次数。用于触发即时编译。

### 基于分支 profile 的优化

根据条件跳转指令的分支 profile，即时编译器可以将从未执行过的分支剪掉，以避免编译这些很有可能不会用到的代码，从而节省编译时间以及部署代码所要消耗的内存空间；还会根据分支 profile，计算每一条程序执行路径的概率，以便某些编译器优化优先处理概率较高的路径。

### 基于类型 profile 的优化

### 去优化

不论是分支profile还是类型profile，都是基于假设去进行剪枝，但是如果假设失败，Java 虚拟机给出的解决方案便是<u>去优化</u>，即从执行即时编译生成的机器码切换回解释执行。

在生成的机器码中，即时编译器将在假设失败的位置上**插入一个陷阱（trap）**。该陷阱实际上是一条 call 指令，调用至 Java 虚拟机里专门负责去优化的方法。与普通的 call 指令不一样的是，<u>去优化方法将更改栈上的返回地址</u>，并不再返回即时编译器生成的机器码中。一旦踏入这些陷阱，便将发生去优化，并切换至解释执行。

