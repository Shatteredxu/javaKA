Redis基础知识
-------------

##### 什么是Redis，优缺点

基于内存的键值对数据库，

***优点：***

读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。
       支持数据持久化，支持AOF和RDB两种持久化方式。
		支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
		数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。
		支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。
***	缺点：***

数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
		Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
		主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。

##### 为什么要用 Redis 而不用 map/guava 做缓存?

##### Redis为什么这么快

1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；

2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；

3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4、使用多路 I/O 复用模型，非阻塞 IO；

5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

##### Redis有哪些数据类型

##### Redis的应用场景

消息队列（List，Stream），缓存()，分布式锁(setnx set)，大数据计算（bitmap,**HyperLogLog**,布隆过滤器，Geohash），限流（基本限流，漏斗限流）,sentinel高可用

### Redis客户端

Jedis：是老牌的Redis的Java实现客户端，提供了比较全面的Redis命令的支持，多线程操作是非线程安全的

Redisson：实现了分布式和可扩展的Java数据结构。**分布式锁，分布式集合，可通过Redis支持延迟队列**，基于Netty框架的事件驱动的通信层，其方法调用是异步的

Lettuce：高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器。

### Redis性能变慢怎么排查

1.  使用复杂度过高的命令（例如SORT/SUION/ZUNIONSTORE/KEYS），或一次查询全量数据（例如LRANGE key 0 N，但N很大）

    >   分析：a) 查看slowlog是否存在这些命令 b) Redis进程CPU使用率是否飙升（聚合运算命令导致）
    >
    >   解决：a) 不使用复杂度过高的命令，或用其他方式代替实现（放在客户端做） b) 数据尽量分批查询（LRANGE key 0 N，建议N<=100，查询全量数据建议使用HSCAN/SSCAN/ZSCAN）

2.  操作bigkey

    >   分析：a) slowlog出现很多SET/DELETE变慢命令（bigkey分配内存和释放内存变慢） b) 使用redis-cli -h $host -p $port --bigkeys扫描出很多bigkey
    >
    >   解决：a) 优化业务，避免存储bigkey b) Redis 4.0+可开启lazy-free机制
    >
    >   
    >
    >   

    3. 大量key集中过期

    分析：a) 业务使用EXPIREAT/PEXPIREAT命令 b) Redis info中的expired_keys指标短期突增

    解决：a) 优化业务，过期增加随机时间，把时间打散，减轻删除过期key的压力 b) 运维层面，监控expired_keys指标，有短期突增及时报警排查

    4、Redis内存达到maxmemory

    分析：a) 实例内存达到maxmemory，且写入量大，淘汰key压力变大 b) Redis info中的evicted_keys指标短期突增

    解决：a) 业务层面，根据情况调整淘汰策略（随机比LRU快） b) 运维层面，监控evicted_keys指标，有短期突增及时报警 c) 集群扩容，多个实例减轻淘汰key的压力

    5、大量短连接请求

    分析：Redis处理大量短连接请求，TCP三次握手和四次挥手也会增加耗时

    解决：使用长连接操作Redis

    6、生成RDB和AOF重写fork耗时严重

    分析：a) Redis变慢只发生在生成RDB和AOF重写期间 b) 实例占用内存越大，fork拷贝内存页表越久 c) Redis info中latest_fork_usec耗时变长

    解决：a) 实例尽量小 b) Redis尽量部署在物理机上 c) 优化备份策略（例如低峰期备份） d) 合理配置repl-backlog和slave client-output-buffer-limit，避免主从全量同步 e) 视情况考虑关闭AOF f) 监控latest_fork_usec耗时是否变长

    7、AOF使用awalys机制

    分析：磁盘IO负载变高

    解决：a) 使用everysec机制 b) 丢失数据不敏感的业务不开启AOF

    8、使用Swap

    分析：a) 所有请求全部开始变慢 b) slowlog大量慢日志 c) 查看Redis进程是否使用到了Swap

    解决：a) 增加机器内存 b) 集群扩容 c) Swap使用时监控报警

    9、进程绑定CPU不合理

    分析：a) Redis进程只绑定一个CPU逻辑核 b) NUMA架构下，网络中断处理程序和Redis进程没有绑定在同一个Socket下

    解决：a) Redis进程绑定多个CPU逻辑核 b) 网络中断处理程序和Redis进程绑定在同一个Socket下

    10、开启透明大页机制

    分析：生成RDB和AOF重写期间，主线程处理写请求耗时变长（拷贝内存副本耗时变长）

    解决：关闭透明大页机制

    11、网卡负载过高

    分析：a) TCP/IP层延迟变大，丢包重传变多 b) 是否存在流量过大的实例占满带宽

    解决：a) 机器网络资源监控，负载过高及时报警 b) 提前规划部署策略，访问量大的实例隔离部署
    
    总之，Redis的性能与CPU、内存、网络、磁盘都息息相关，任何一处发生问题，都会影响到Redis的性能。
    
    主要涉及到的包括业务使用层面和运维层面：业务人员需要了解Redis基本的运行原理，使用合理的命令、规避bigke问题和集中过期问题。运维层面需要DBA提前规划好部署策略，预留足够的资源，同时做好监控，这样当发生问题时，能够及时发现并尽快处理

### Redis如何面对数据倾斜问题

