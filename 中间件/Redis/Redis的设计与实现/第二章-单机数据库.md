### 数据库

>   本章介绍服务器**保存数据库**的方法，客户端**切换数据库**的方法，数据库**保存键值对**的方法，以及针对**数据库的添加**、删除、查看、更新操作的实现方法等。除此之外，本章还会说明服务器**保存键的过期时间的方法**，以及**服务器自动删除过期键**的方法。最后，本章还会说明Redis 2.8新引入的数据库通知功能的实现方法。

Redis服务器数据库都保存在redis.h/redisServer结构的db数组中，db数组是一个指针, 每个项都是一个redis.h/redisDb结构，代表一个数据库,数据库的数量由dbnum来决定，默认16个。

##### 切换数据库

通过selecrt 2来切换数据库，切换操作是由redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。

每一个redisDb都存储着dict指针，指向本数据库中的键值对，其更新，删除，添加操作都是对字典进行直接操作。

##### 键的生存时间或过期时间

通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键

redisDb结构的**expires字典**保存了数据库中所有键的过期时间，我们称这个字典为**过期字典**：

​    ❑过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。

​    ❑过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。

PERSIST命令可以移除一个键的过期时间：PERSIST命令就是PEXPIREAT命令的反操作

TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间：

##### 过期键删除策略

三种过期删除策略：

​	❑定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。（对CPU不友好,定时删除可能发生在CPU最紧张的时候，会占用CPU时间）

   ❑惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。（对内存不够友好，因为有些键可能永远不会用到，那么及时过期了也没有删除，从而占用空间）

​    ❑定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。（难以确定删除操作执行时长和执行频率）

##### 过期删除具体实现

***惰性删除策略：***过期键的惰性删除策略由db.c/expireIfNeeded函数实现，在执行set，updata等命令时，先调用expireIfNeeded函数确认键是否过期。

***定期删除策略：***过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每隔一段时间取出一定量的随机键调用activeExpireCycle进行检查，下一次调用时，会从上一次进度之后进行取键，然后分批进行删除，直到数据库中所有的键都检查完毕

### RDB持久化

##### 创建与载入

***创建：***SAVE（会阻塞服务器进程）和 BGSAVE（派生子进程来创建）

***载入：***启动时会载入文件，**优先载入AOF文件**，载入期间，服务器会一直阻塞。

##### 自动间隔保存

用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足,就会执行save命令；

redisServer结构的**saveparams属性**用于保存save条件

**dirty计数器：**dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。

**lastsave属性：**lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。

Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，检查保存条件是否被满足。

##### RDB文件结构

由REDIS字符，db_version长度为4字节，databases部分，EOF常量，check_sum，

***databases部分***：包含着零个或任意多个数据库，由于键值对的数量不同，编码不同导致长度也会有不同。

​		每个数据库有SELECTDB、db_number、key_value_pairs三个部分，***key_value_pairs***保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。由TYPE、key、value三部分组成：TYPE记录了value的类型，长度为1字节，程序会根据TYPE的值来决定如何读入和解释value的数据；key总是一个字符串对象，它的编码方式和REDIS_RDB_TYPE_STRING类型的value一样；每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。（字符串对象，列表对象，集合对象，哈希表对象，有序集合对象，整数集合对象，压缩列表对象，）

***EOF:***长度为1字节，这个常量标志着RDB文件正文内容的结束

***check_sum***是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。	

### AOF持久化

AOF持久化是通过保存Redis服务器所**执行的写命令**来记录数据库状态的

AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。

1.  将命令追加到aof_buf缓冲区里面
2.  将写入缓冲区的命令刷到磁盘中，系统提供了**fsync和fdatasync两个同步函数**，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。

​	服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性：当appendfsync的值为always，当appendfsync的值为everysec时，当appendfsync的值为no时

***AOF文件重写：***将原始的AOF文件进行重写，重写后的文件体积比原始要小很多，并且数据库状态相同。

***重写实现原理：***数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。

***重写过程中发生的数据更改怎么去解决：***为了解决这种数据不一致问题，Redis服务器设置了一个**AOF重写缓冲区**，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区

这也就是说，在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：

1）执行客户端发来的命令。

2）将执行后的写命令追加到AOF缓冲区。

3）将执行后的写命令追加到AOF重写缓冲区

以上同时也是**BGREWRITEAOF**的实现原理。

##### RDB持久化和AOF持久化区别，优缺点

RDB优点：

- 如果要进行大规模数据的恢复，RDB方式要比AOF方式恢复速度要快。
- RDB可以最大化Redis性能，父进程做的就是fork子进程，然后继续接受客户端请求，让子进程负责持久化操作，父进程无需进行IO操作。
- RDB是一个非常紧凑(compact)的文件,它保存了某个时间点的数据集，非常适合用作备份，同时也非常适合用作灾难性恢复，它只有一个文件，内容紧凑，通过备份原文件到本机外的其他主机上，一旦本机发生宕机，就能将备份文件复制到redis安装目录下，通过启用服务就能完成数据的恢复。

RDB缺点：

- RDB这种持久化方式不太适应对数据完整性要求严格的情况，因为，尽管我们可以用过修改快照实现持久化的频率，但是要持久化的数据是一段时间内的整个数据集的状态，如果在还没有触发快照时，本机就宕机了，那么对数据库所做的写操作就随之而消失了并没有持久化本地dump.rdb文件中。
- 每次进行RDB时，父进程都会fork一个子进程，由子进程来进行实际的持久化操作，如果数据集庞大，那么fork出子进程的这个过程将是非常耗时的，就会出现服务器暂停客户端请求，将内存中的数据复制一份给子进程，让子进程进行持久化操作

AOF优点：

- AOF有着多种持久化策略：
    appendfsync always:每修改同步，每一次发生数据变更都会持久化到磁盘上，性能较差，但数据完整性较好。appendfsync everysec: 每秒同步，每秒内记录操作，异步操作，如果一秒内宕机，有数据丢失。appendfsync no:不同步。

- AOF文件是一个只进行追加操作的日志文件，对文件写入不需要进行seek，即使在追加的过程中，写入了不完整的命令（例如：磁盘已满），可以使用redis-check-aof工具可以修复这种问题
    - Redis可以在AOF文件变得过大时，会自动地在后台对AOF进行重写：重写后的新的AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis在创建AOF文件的过程中，会继续将命令追加到现有的AOF文件中，即使在重写的过程中发生宕机，现有的AOF文件也不会丢失。一旦新AOF文件创建完毕，Redis就会从旧的AOF文件切换到新的AOF文件，并对新的AOF文件进行追加操作。
- AOF文件有序地保存了对数据库执行的所有写入操作。这些写入操作Redis协议的格式保存，易于对文件进行分析；例如，如果不小心执行了FLUSHALL命令，但只要AOF文件未被重写，通过停止服务器，移除AOF文件末尾的FLUSHALL命令，重启服务器就能达到FLUSHALL执行之前的状态。

AOF缺点：

- 对于相同的数据集来说，AOF文件要比RDB文件大。

- 根据所使用的持久化策略来说，AOF的速度要慢与RDB。一般情况下，每秒同步策略效果较好。不使用同步策略的情况下，AOF与RDB速度一样快。

##### RDB文件

创建：SAVE和BGSAVE（创建子进程去处理）。

自动载入，如果AOF开启，则优先处理AOF

saveparams数组设置了多个saveparam格式的保存状态

dirty计数器和lastsave属性

每隔100ms调用serverCron来检查是否满足save条件

36. RDB文件的格式

    REDIS,db_version,databases,EOF,check_sum

    database部分有：SELECTDB、db_number、==key_value_pairs==三个部分

    key_value_pairs：TYPE（1字节记录value类型）、key、value；不同type类型的键保存格式不同

    对不同类型value存储形式也不同

37. od命令分析RDB文件

    od -c命令；RDB文件检查工具：redis-check-dump

3. 有关持久化的资料

    http://blog.nosqlfan.com/html/3813.html
