Redis集群方案
-------------

### 1.主从复制模式

主从复制模式中包含一个主数据库实例（master）与一个或多个从数据库实例（slave）

具体工作机制为：

1.  slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过bgsave保存快照（即上文所介绍的RDB持久化），并使用缓冲区记录保存快照这段时间内执行的写命令
2.  master将保存的快照文件发送给slave，并继续记录执行的写命令
3.  slave接收到快照文件后，加载快照文件，载入数据
4.  master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化
5.  此后master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性

##### 优缺点

优点就是：是一个解决办法，缺点就是：不具备自动容错与恢复功能；master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题

### 2.Sentinel（哨兵）模式

[Sentinel详解](./Redis的设计与实现\Sentinel.md)

1.  监控master、slave是否正常运行
2.  当master出现故障时，能自动将一个slave转换为master（大哥挂了，选一个小弟上位）
3.  多个哨兵可以监控同一个Redis，哨兵之间也会自动监控

优缺点：**优点：**基于主从复制，保证并且读写分离，master能够自动切换；**缺点**：slave节点作为备份节点不提供服务，浪费机器；难以在线扩容

### Redis-Cluster模式



[redis集群](./Redis的设计与实现\Redis集群.md)

哨兵模式解决了主从复制不能自动故障转移，但还是存在难以在线扩容，而Redis-Cluster模式采用无中心结构，解决了在线扩容问题，Cluster模式集群节点最小配置**6个节点(3主3从，因为需要半数以上)**，其中**主节点提供读写操作**，从节点作为备用节点，<u>不提供请求，只作为故障转移使用</u>。

1.  所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽
2.  节点的fail是通过集群中超过半数的节点检测失效时才生效
3.  客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可

具体工作机制：

1.  在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383
2.  当我们存取key的时候，Redis会根据CRC16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作
3.  为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点
4.  当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了

##### 优缺点

**优点：**通过slot将节点分布到多个slot，最多可扩展到1000多个节点，可动态添加或者删除，节点之间通过**gossip协议**交换状态信息，用投票机制完成slave到master的角色转换,能够实现自动故障转移。

**缺点：**不保证数据的强一致性，slave充当“冷备”，不能缓解读压力，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能

### Gossip协议

[详解](http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%AE%8C%EF%BC%89/04%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20Gossip%20%E5%92%8C%20Redis%20%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.md)

在分布式系统中，需要提供维护节点元数据信息的机制，所谓元数据是指节点负责哪些数据、主从属性、是否出现故障等状态信息。常见的元数据维护方式分为集中式和无中心式。Redis Cluster 采用 Gossip 协议实现了无中心式。Redis Cluster 中使用 Gossip 主要有两大作用：**1. 去中心化，以实现分布式和弹性扩展；2.失败检测，以实现高可用；**

##### ***通信机制：***

Redis Cluster 中的每个 Redis 实例监听两个 TCP 端口，<u>6379</u>（默认）用于服务客户端查询，<u>16379</u>（默认服务端口+10000）用于集群内部通信。集群中节点通信方式如下：通过这种机制，每个节点**最终会达到一致性状态**

*   每个节点在固定周期内通过特定规则选择几个节点发送 Ping 消息；
*   接收到 Ping 消息的节点用 Pong 消息作为响应。

##### 消息种类

Gossip 消息种类：Ping 消息、Pong 消息、Meet 消息、Fail 消息

*   Meet 消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，Meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 Ping、Pong 消息交换；
*   Ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其它节点发送 Ping 消息，**用于检测节点是否在线和交换彼此状态信息**。Ping 消息发送封装了自身节点和部分其它节点的状态数据；
*   Pong 消息：当接收到 Ping、Meet 消息时，作为响应消息回复给发送方确认消息正常通信。**Pong 消息内部封装了自身状态数据**。节点也可以向集群内广播自身的 Pong 消息来通知整个集群对自身状态进行更新；
*   Fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 Fail 消息，其他节点接收到 Fail 消息之后把对应节点更新为下线状态。

##### 节点通信

1.   Redis 节点启动之后，会每间隔 100ms 执行一次集群的周期性函数 `clusterCron()`函数，`clusterCron()` 中又会调用 `clusterSendPing()` 函数，该函数用于将随机选择的节点的信息加入到 Ping 消息体中，然后发送出去。

     >   1.  当前节点向另一个节点发送 Ping 消息时，**携带的其它节点的消息数量至少为3，最大等于集群节点总数-2；**
     >   2.  为 Ping 消息体中选择携带的其它节点的信息时，采用的是**混合选择模式：随机选择+偏好性选择**，这样不仅可以保证 Gossip 协议随机传播的原则，还可以尽量将当前节点掌握的其它节点的故障信息传播出去。

2.   集群的周期性函数 `clusterCron()` 执行周期是 100ms，为了保证传播效率，每10个周期，也就是 1s，每个节点都会随机选择5个其它节点，并从中选择一个最久没有通信的节点发送 ping消息,为了避免有些节点一直不能发送，<u>对那些长时间没有“被” 随机到的节点进行特殊照顾</u>：每个周期（100ms）内扫描一次本地节点列表，如果发现节点最近一次接受 Pong 消息的时间大于 `cluster_node_timeout/2`，则立刻发送 Ping 消息，防止该节点信息太长时间未更新

3.   故障检测，自主切换

     >   **单点视角检测**：发送ping信息在规定时间没有返回pong信息
     >
     >   **检测信息传播**：将某节点下线信息保存下来，发送给其他节点
     >
     >   **基于检测信息作下线判决**：超过半数的持有 Slot（槽）的主节点都将某个主节点 X 报告为疑似下线，那么，主节点 X 将被标记为下线（Fail），并广播出去，所有收到这条 Fail 消息的节点都会立即将主节点 X 标记为 Fail。至此，故障检测完成。

4.   选举

     >   主节点被标记为 Fail 后，对应的从节点会发起投票，竞争升主。历经从节点拉票、主节点投票、投票裁决等环节，最终完成选举。以下是详细过程。
     >
     >   基于Raft选举算法
     >
     >   1.   **从节点拉票**，

     Redis Cluster 模式下，**16384个 Slot 中只要有任意一个 Slot 不可用，整个集群都将不可用**，换言之，任何一个被指派 Slot 的主节点故障，在其恢复期间，集群都是不可用的。鉴于此，Redis Cluster 并不适合超大规模商用场景，国内 IT 巨头基本上采用的都是自研的集群方案，如阿里云 ApsaraDB for Redis/ApsaraCache，腾讯的 CRS。当然，Redis Cluster 也有很成功的商用案例，像亚马逊采用的就是 Redis Cluster。