Netty设计原理
-------------

需要了解的原理：有**I/O 模型** 、**内存管理**、**线程模型**、**数据结构**

提供的：**拆包/粘包、数据编解码、TCP 断线重连**

### 1. I/O模型

##### 同步阻塞 I/O（BIO）

##### 同步非阻塞 I/O（NIO）

先前的NIO缺点：

1.  NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer等；
2.  需要具备其他的额外技能：要熟悉 **Java 多线程编程**，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序；
3.  开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等；
4.  JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU100%。直到 JDK1.7 版本该问题仍旧存在，没有被根本解决；

##### I/O 多路复用

[IO模型和epoll](../中间件\Netty\IO模型.md)

信号驱动 I/O

异步 I/O

**对象池复用技术**，**零拷贝技术**

### 2. 线程模型

https://github.com/coderbruis/JavaSourceCodeLearning/blob/master/note/Netty/Netty%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%88%9D%E5%A7%8BNetty%E5%8F%8A%E5%85%B6%E6%9E%B6%E6%9E%84.md

##### 目前存在的线程模型有：传统阻塞 I/O 服务模型 和Reactor 模式；

根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现:

*   单Reactor单线程；
*   单Reactor多线程；
*   主从Reactor多线程；

<u>Netty 线程模式</u>（Netty 主要基于主从 Reactor 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor）

##### 传统阻塞 I/O 服务

### Reactor 模式

IO 复用+线程池，就是 Reactor 模式基本设计思想；**IO模型决定如何收发数据，线程模型决定如何处理数据**

基于 I/O 多路复用模型：**多个连接共用一个阻塞对象ServiceHandler**，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。

> 1.  基于线程池复用线程资源：不必再为每个连接创建线程，**将连接完成后的业务处理任务分配给线程进行处理**，一个线程可以处理多个连接的业务。（解决了当并发数很大时，会创建大量线程，占用很大系统资源）
> 2.  基于 I/O 复用模型：多个客户端进行连接，先把连接请求给ServiceHandler。多个连接共用一个阻塞对象ServiceHandler。假设，当C1连接没有数据要处理时，C1客户端只需要阻塞于ServiceHandler，C1之前的处理线程便可以处理其他有数据的连接，不会造成线程资源的浪费。当C1连接再次有数据时，ServiceHandler根据线程池的空闲状态，将请求分发给空闲的线程来处理C1连接的任务。（解决了线程资源浪费的那个问题）

##### Netty中的Reactor模型

select 是Reactor中的一个组件，也可以说是最核心的组件，为整个模块提供注**册事件和监听事件的功能**，从另一个的角度来说就是事件的派发，他将可能引起的阻塞等待集中到自身这一个地方进行协调处理，可以实现在单个进程中高效的I/O复用。

<img src="assets/Netty的Reactor模型.png" alt="first-netty08" style="zoom:20%;" />

Netty线程模型流程分析：

1. Netty 抽象出**两组线程池** ，**BossGroup 专门负责接收客户端的连接，WorkerGroup 专门负责网络的读写**。
2. BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup
3. NioEventLoopGroup 相当于一个**事件循环组**，这个组中含有多个事件循环，每一个事件循环是 NioEventLoop
4. NioEventLoop 表示一个不断循环的执行处理任务的线程，每个 NioEventLoop 都有一个 Selector，用于监听绑定在其上的 socket 的网络通讯
5. NioEventLoopGroup 可以有多个线程，即可以含有多个 NioEventLoop
6. 每个 BossGroup下面的NioEventLoop 循环执行的步骤有 3 步
   - 轮询 accept 事件
   - 处理 accept 事件，与 client 建立连接，生成 NioScocketChannel，并将其注册到某个 workerGroup NIOEventLoop 上的 Selector
   - 继续处理任务队列的任务，即 runAllTasks
7. 每个 WorkerGroup NIOEventLoop 循环执行的步骤
   - 轮询 read，write 事件
   - 处理 I/O 事件，即 read，write 事件，在对应 NioScocketChannel 处理
   - 处理任务队列的任务，即 runAllTasks
8. 每个 Worker NIOEventLoop 处理业务时，会使用 pipeline（管道），pipeline 中包含了 channel（通道），即通过 pipeline 可以获取到对应通道，管道中维护了很多的处理器

### Netty整体架构

#### 1. Core 核心层

Core 核心层是 Netty 最精华的内容，它提供了底层网络通信的通用抽象和实现，包括可扩展的事件模型、通用的通信 API、支持零拷贝的 ByteBuf 等。

#### 2. Protocol Support 协议支持层

协议支持层基本上覆盖了主流协议的编解码实现，如 HTTP、SSL、Protobuf、压缩、大文件传输、WebSocket、文本、二进制等主流协议，此外 Netty 还支持自定义应用层协议。Netty 丰富的协议支持降低了用户的开发成本，基于 Netty 我们可以快速开发 HTTP、WebSocket 等服务。

#### 3. Transport Service 传输服务层

传输服务层提供了网络传输能力的定义和实现方法。它支持 Socket、HTTP 隧道、虚拟机管道等传输方式。Netty 对 TCP、UDP 等数据传输做了抽象和封装，用户可以更聚焦在业务逻辑实现上，而不必关系底层数据传输的细节。

### 逻辑架构

网络通信层、



事件调度层、



服务编排层

### Netty组件

Reactor ，Selector ，EventLoop，ChannelPipeline ，ChannelHandler 

### Netty关键属性

##### 性能

1.  采用非阻塞的 **NIO 类库**，基于 Reactor 模式实现，解决了传统 同步阻塞 IO 模式 下一个服务端无法平滑地处理线性增长的客户端的问题。
2.  TCP 接收和发送缓冲区**使用直接内存代替堆内存，避免了内存复制**，提升了 IO 读取和写入的性能。
3.  支持通过**内存池**的方式**循环利用 ByteBuffer**，避免了频繁创建和销毁 ByteBuffer 带来的性能损耗。
4.  可配置的 IO 线程数、TCP 参数 等，为不同的用户场景提供定制化的调优参数，满足不同的性能场景。
5.  采用**环形数组缓冲区实现无锁化并发编程**，代替传统的线程安全容器或者锁。
6.  合理地使用线程安全容器、原子类等，提升系统的并发处理能力。
7.  关键资源的处理使用**单线程串行化**的方式，避免多线程并发访问带来的锁竞争和额外的 CPU 资源消耗问题。
8.  通过**引用计数器**及时地申请释放不再被引用的对象，细粒度的内存管理降低了 GC 的频率，减少了频繁 GC 带来的延时和 CPU 损耗。

##### 可靠

**1. 链路有效性检测**

​	使用长连接，并且定期进行心跳检测，检测链路的有效性，可用性。Netty 提供了如下两种链路空闲检测机制：

*   **读空闲超时机制：**当经过连续的周期 T 没有消息可读时，触发 超时 Handler，用户可以基于该读空闲超时 Handler 发送心跳消息，进行链路检测，如果连续 N 个周期 仍然没有读取到心跳消息，可以主动关闭这条链路。
*   **写空闲超时机制：**当经过连续的周期 T 没有消息要发送时，触发超时 Handler，用户可以基于该写空闲超时 Handler 发送心跳消息，进行链路检测，如果连续 N 个周期 仍然没有接收到对方的心跳消息，可以主动关闭这条链路。

为了满足不同用户场景的心跳定制，Netty 提供了空闲状态检测事件通知机制，用户可以订阅：空闲超时事件、读空闲超时机制、写空闲超时事件，在接收到对应的空闲事件之后，灵活地进行定制。

2.   **内存保护机制** 

*   通过对象引用计数器对 Netty 的 ByteBuffer 等内置对象进行细粒度的内存申请和释放，对非法的对象引用进行检测和保护。
*   通过内存池来重用 ByteBuffer，节省内存。
*   可设置的内存容量上限，包括 ByteBuffer、线程池线程数等。

3.   可定制性

*   **责任链模式：**ChannelPipeline 基于责任链模式开发，便于业务逻辑的拦截、定制和扩展。
*   **基于接口的开发：**关键的类库都提供了接口或者抽象类，如果 Netty 自身的实现无法满足用户的需求，可以由用户自定义实现相关接口。
*   提供了大量工厂类，通过重载这些工厂类可以按需创建出用户实现的对象。
*   提供了大量的系统参数供用户按需设置，增强系统的场景定制性。

4.   可扩展性



基于 Netty 的 基本 NIO 框架，可以方便地进行**应用层协议定制**，例如，HTTP 协议栈、Thrift 协议栈、FTP 协议栈 等。这些扩展不需要修改 Netty 的源码，直接基于 Netty 的二进制类库即可实现协议的扩展和定制。例如基于 Netty 的 HTTP 协议、Dubbo 协议、RocketMQ 内部私有协议 等。