### Netty为什么性能这么高呢？

Netty的高性能主要可以总结为如下几点：

1.  Netty作为异步事件驱动的网络，高性能之处主要来自于其**I/O模型和线程处理模型**，不同于传统BIO，客户端的连接以及事件处理都阻塞在同一个线程里，Netty则将客户端的线程和处理客户端的线程分离开来；（高效的Reactor线程模型）
2.  Netty的IO线程NioEventLoop由于聚合了**多路复用器Selector**，可以同时并发处理成百上千个客户端连接；（IO多路复用模型）
3.  Netty底层还实现了**零拷贝**，避免了IO过程中数据在操作系统底层来回”无效的“拷贝和系统态切换；（零拷贝）
4.  **无锁串行化设计**，串行设计：消息的处理尽可能在一个线程内完成，期间不进行线程切换，避免了多线程竞争和同步锁的使用；（单线程）
5.  Netty 默认提供了对Google Protobuf 的支持，通过扩展Netty 的编解码接口，可以实现其它的高性能序列化框架（高性能的序列化框架）
6.  Netty中大量使用了volatile，读写锁，CAS和原子类；（高效并发编程）
7.  Netty的内存分配管理实现非常高效，Netty内存管理分为了池化（Pooled）和非池化（UnPooled），heap（堆内内存）和direct（堆外内存），对于Netty默认使用的是池化内存管理，其内部维护了一个内存池可以循环的创建ByteBuf（Netty底层实现的一个Buffer），提升了内存的使用效率，降低由于高负载导致的频繁GC。同时Netty底层实现了jemalloc算法（jemalloc3实现的满二叉树，读内存进行一个分隔、jemalloc4则优化了jemalloc3的算法，实现了将内存切割成了一个二维数组维护的一个数据结构，提升了内存的使用率）（Netty内存管理非常高效）

### Netty关键属性

##### 性能

1.  采用非阻塞的 **NIO 类库**，基于 Reactor 模式实现，解决了传统 同步阻塞 IO 模式 下一个服务端无法平滑地处理线性增长的客户端的问题。
2.  TCP 接收和发送缓冲区**使用直接内存代替堆内存，避免了内存复制**，提升了 IO 读取和写入的性能。
3.  支持通过**内存池**的方式**循环利用 ByteBuffer**，避免了频繁创建和销毁 ByteBuffer 带来的性能损耗。
4.  可配置的 IO 线程数、TCP 参数 等，为不同的用户场景提供定制化的调优参数，满足不同的性能场景。
5.  采用**环形数组缓冲区实现无锁化并发编程**，代替传统的线程安全容器或者锁。
6.  合理地使用线程安全容器、原子类等，提升系统的并发处理能力。
7.  关键资源的处理使用**单线程串行化**的方式，避免多线程并发访问带来的锁竞争和额外的 CPU 资源消耗问题。
8.  通过**引用计数器**及时地申请释放不再被引用的对象，细粒度的内存管理降低了 GC 的频率，减少了频繁 GC 带来的延时和 CPU 损耗。

##### 可靠

**1. 链路有效性检测**

​	使用长连接，并且定期进行心跳检测，检测链路的有效性，可用性。Netty 提供了如下两种链路空闲检测机制：

*   **读空闲超时机制：**当经过连续的周期 T 没有消息可读时，触发 超时 Handler，用户可以基于该读空闲超时 Handler 发送心跳消息，进行链路检测，如果连续 N 个周期 仍然没有读取到心跳消息，可以主动关闭这条链路。
*   **写空闲超时机制：**当经过连续的周期 T 没有消息要发送时，触发超时 Handler，用户可以基于该写空闲超时 Handler 发送心跳消息，进行链路检测，如果连续 N 个周期 仍然没有接收到对方的心跳消息，可以主动关闭这条链路。

为了满足不同用户场景的心跳定制，Netty 提供了空闲状态检测事件通知机制，用户可以订阅：空闲超时事件、读空闲超时机制、写空闲超时事件，在接收到对应的空闲事件之后，灵活地进行定制。

2.   **内存保护机制** 

*   通过对象引用计数器对 Netty 的 ByteBuffer 等内置对象进行细粒度的内存申请和释放，对非法的对象引用进行检测和保护。
*   通过内存池来重用 ByteBuffer，节省内存。
*   可设置的内存容量上限，包括 ByteBuffer、线程池线程数等。

3.   可定制性

*   **责任链模式：**ChannelPipeline 基于责任链模式开发，便于业务逻辑的拦截、定制和扩展。
*   **基于接口的开发：**关键的类库都提供了接口或者抽象类，如果 Netty 自身的实现无法满足用户的需求，可以由用户自定义实现相关接口。
*   提供了大量工厂类，通过重载这些工厂类可以按需创建出用户实现的对象。
*   提供了大量的系统参数供用户按需设置，增强系统的场景定制性。

4.   可扩展性



基于 Netty 的 基本 NIO 框架，可以方便地进行**应用层协议定制**，例如，HTTP 协议栈、Thrift 协议栈、FTP 协议栈 等。这些扩展不需要修改 Netty 的源码，直接基于 Netty 的二进制类库即可实现协议的扩展和定制。例如基于 Netty 的 HTTP 协议、Dubbo 协议、RocketMQ 内部私有协议 等。

### Netty封装了那些东西

如果没有Netty，我们一个网络IO需要以下几个步骤：1. Listen监听端口 2. Accept接受新连接 3. 不断轮询Read数据4.使用Write发送数据

在Netty中，封装后：1. 监听端口<u>NioEventLoop</u>  2. 一个socket连接：<u>Channel</u>；3.接受数据 <u>ByteBuf</u> 4. 业务处理 <u>ChannelHandle</u>

### Netty组件

