## 分布式事务

### 1.什么是分布式事务

分布式事务就是一个业务操作，是由多个细分操作完成的，而这些细分操作又分布在不同的服务器上；事务，就是这些操作要么全部成功执行，要么全部不执行

分布式事务是伴随着系统拆分出现的，前面我们说过，分布式系统解决了海量数据服务对扩展性的要求，但是增加了架构上的复杂性，在这一点上，分布式事务就是典型的体现。

在实际开发中，分布式事务产生的原因主要来源于**存储和服务的拆分**。

### 2.分布式事务解决方案

##### 2PC 两阶段提交

存在一个节点作为协调者，其他为参与者，所有节点都采用**预写式日志**，日志被写入后被保存在可靠的存储设备上，即使节点损坏也不会导致日志数据的丢失；

缺点：

1.   资源被同步阻塞
2.   协调者可能出现单点故障
3.   在 Commit 阶段出现数据不一致

##### 3PC 三阶段提交

三阶段中的 Three Phase 分别为 CanCommit、PreCommit、DoCommit 阶段。在2pc的第二阶段将执行事务，不提交，

<img src="assets/CgqCHl66P8OAOon7AALWZvqApaI286.png" alt="image" style="zoom: 50%;" />

三阶段提交**引入超时机制**，**添加预提交阶段**，但是如果在preCommit后节点与协调者之间出现了问题，还是不能正常提交



##### TCC 分段提交

##### 基于消息补偿的最终一致性

<img src="assets/Cgq2xl6YKgaAVUwAAAFePtc8mmU340.png" alt="img" style="zoom:47%;" />

（1）系统收到下单请求，将订单业务数据存入到订单库中，并且同时存储该订单对应的消息数据，比如购买商品的 ID 和数量，消息数据与订单库为同一库，更新订单和存储消息为一个本地事务，要么都成功，要么都失败。

（2）库存服务通过消息中间件收到库存更新消息，调用库存服务进行业务操作，同时返回业务处理结果。

（3）消息生产方，也就是订单服务收到处理结果后，将本地消息表的数据删除或者设置为已完成。

（4）设置异步任务，定时去扫描本地消息表，发现有未完成的任务则重试，保证最终一致性。

### 2.分布式锁

[分布式锁](https://zhuanlan.zhihu.com/p/42056183)

**分布式锁应该具有的特征：**

- **互斥性**，互斥是锁的基本特征，同一时刻只能有一个线程持有锁，执行临界操作；
- **超时释放**，超时释放是锁的另一个必备特性，可以对比 MySQL InnoDB 引擎中的 innodb_lock_wait_timeout 配置，通过超时释放，防止不必要的线程等待和资源浪费；
- **可重入性**，在分布式环境下，同一个节点上的同一个线程如果获取了锁之后，再次请求还是可以成功；
- **高性能和高可用**，加锁和解锁的开销要尽可能的小，同时也需要保证高可用，防止分布式锁失效；
- **支持阻塞和非阻塞性**，对比 Java 语言中的 wait() 和 notify() 等操作，这个一般是在业务代码中实现，比如在获取锁时通过 while(true) 或者轮询来实现阻塞操作。

##### 1.基于数据库做分布式锁

基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。

当我们需要锁资源就向数据库中插入一条记录，释放锁时候就删除锁记录。

基于数据库实现分布式锁操作简单，但是并不是一个可以落地的方案，存在多个问题：1.**存在单点故障风险**2.**超时无法失效**3.**不可重入**4.**无法实现阻塞**：插入失败直接返回，不会阻塞线程，如果需要阻塞线程，要不断的重试 insert 操作，直到数据插入成功。



##### 2.基于 Redis 做分布式锁

[参考](http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C/12%20%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Redis%20%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F.md)

***单机情况下：***

 setnx 和 expire 命令实现加锁。

使用 setnx 和 expire 有一个问题，这两条命令可能不会同时失败，不具备原子性，如果一个线程在执行完 setnx 之后突然崩溃，导致锁没有设置过期时间，那么这个锁就会一直存在，无法被其他线程获取。

为了解决这个问题，在 Redis 2.8 版本中，添加了 SETEX 命令，SETEX 支持 setnx 和 expire 指令组合的原子操作，解决了加锁过程中失败的问题。

- **互斥性**: setnx 和 expire 命令即可满足。

- **超时释放**：**set 扩展命令实现**来解决setnx和expire不能保证原子性的问题SET key value expireTime nx

- **可重入性**：

- **高性能和高可用**：Redis 集群数据同步是异步的，假设 Master 节点获取到锁后在未完成数据同步的情况下，发生节点崩溃，此时在其他节点依然可以获取到锁，出现多个客户端同时获取到锁的情况。

  所以分布式下的Redis锁实现，一般采用**RedLock算法来实现**

- **支持阻塞和非阻塞性**，对比 Java 语言中的 wait() 和 notify() 等操作，这个一般是在业务代码中实现，比如在获取锁时通过 while(true) 或者轮询来实现阻塞操作。



##### 3.基于 Redlock 做分布式锁

**Redlock 算法**是在单 Redis 节点基础上引入的**高可用模式**，Redlock 基于 N 个完全独立的 Redis 节点，一般是**大于 3 的奇数个**（通常情况下 N 可以设置为 5），可以基本保证集群内各个节点不会同时宕机。

假设当前集群有 5 个节点，运行 Redlock 算法的客户端依次执行下面各个步骤，来完成获取锁的操作：

- 客户端记录当前系统时间，以毫秒为单位；
- 依次尝试从 5 个 Redis 实例中，使用相同的 key 获取锁，当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，超时时间应该小于锁的失效时间，避免因为网络故障出现的问题；
- 客户端使用当前时间减去开始获取锁时间就得到了获取锁使用的时间，当且仅当从半数以上的 Redis 节点获取到锁，并且当使用的时间小于锁失效时间时，锁才算获取成功；
- 如果获取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间，减少超时的几率；
- 如果获取锁失败，客户端应该在所有的 Redis 实例上进行解锁，即使是上一步操作请求失败的节点，防止因为服务端响应消息丢失，但是实际数据添加成功导致的不一致。

在 Redis 官方推荐的 Java 客户端 Redisson 中，内置了对 RedLock 的实现。下面是官方网站的链接，感兴趣的同学可以去了解一下： [redis-distlock](https://redis.io/topics/distlock) [redisson-wiki](https://github.com/redisson/redisson/wiki)

##### 4.基于 ZooKeeper 做分布式锁

当客户端对某个方法加锁时，在 ZooKeeper 中该方法对应的指定节点目录下，生成一个唯一的临时有序节点。

判断是否获取锁，只需要判断持有的节点是否是有序节点中序号最小的一个，当释放锁的时候，将这个临时节点删除即可，这种方式可以避免服务宕机导致的锁无法释放而产生的死锁问题

下面描述使用 ZooKeeper 实现分布式锁的算法流程，根节点为 /lock：

- 客户端连接 ZooKeeper，并在 /lock 下创建临时有序子节点，第一个客户端对应的子节点为 /lock/lock01/00000001，第二个为 /lock/lock01/00000002；
- 其他客户端获取 /lock01 下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；
- 如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听 /lock01 的子节点变更消息，获得变更通知后重复此步骤直至获得锁；
- 完成业务流程后，删除对应的子节点，释放分布式锁。

### 5.分布式事务

有**XA规范**和**TCC模型**

[参考：](http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C/10%20%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E4%BD%93%E7%8E%B0%20TCC%20%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B%EF%BC%9F.md)

#### XA规范

XA 是由 X/Open 组织提出的分布式事务规范，XA 规范主要定义了事务协调者（Transaction Manager）和资源管理器（Resource Manager）之间的接口。是两阶段提交的一种实现方式，根据 2PC 的规范，XA 将一次事务分割成了两个阶段，即 Prepare 和 Commit 阶段。

MySQL 中 XA 事务有两种情况，内部 XA 和外部 XA;**内部XA**是mysql通过bin log和redo log来维护系统的一致性

**外部 XA** 就是典型的分布式事务，MySQL 支持 XA START/END/PREPARE/Commit 这些 SQL 语句，通过使用这些命令，可以完成分布式事务。

#### TCC模型



TCC 提出了一种新的事务模型，基于业务层面的事务定义，锁粒度完全由业务自己控制，目的是解决复杂业务中，**跨表跨库等大颗粒度资源锁定的问题**。TCC 把事务运行过程分成 Try、Confirm / Cancel 两个阶段，每个阶段的逻辑由业务代码控制，避免了长事务，可以获取更高的性能。

### Paxos

[参考](http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C/03%20%E5%A6%82%E4%BD%95%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3%20Paxos%20%E7%AE%97%E6%B3%95%EF%BC%9F.md)

Paxos将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):

*   **Proposer**: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。
*   **Acceptor**：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。
*   **Learner**：不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value）



### 分布式事务常见的开源组件

阿里巴巴开源组件**seata**把一个分布式事务拆分成一个包含了若干分支事务（Branch Transaction）的全局事务（Global Transaction）。分支事务本身就是一个满足 ACID 的 本地事务，全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。



### TCC 分布式事务

> Tcc属于两阶段提交事务，分别为Try(尝试阶段), confirm(确认阶段), cancel(取消阶段) .Try操作作为一阶段，负责资源的检查和预留，Confirm操作作为二阶段提交操作，执行真正的业务，Cancel是预留资源的取消；
>
> 首先第一阶段进行冻结库存等预处理操作来确认服务器是否可用，如果收到返回后则开始进入第二阶段confirm，将之前的信息进行真实的减库存，这个阶段只进行基本的更新操作。如果失败则进入取消阶段，将之前的操作全部回滚取消。

seata就是一款基于AT, TCC, SAGA的分布式事务解决方案。

常用的 TCC 开源组件有 Tcc-transaction、ByteTCC、Spring-cloud-rest-tcc 等。