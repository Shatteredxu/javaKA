### 1.高并发场景下，保证缓存和数据库一致性方案

https://www.zhihu.com/question/458352302/answer/2309776827

>   1. 想要提高应用的性能，可以引入缓存来解决
>
>   2. 引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：更新缓存+更新数据库（批量异步写回数据库）**更新数据库 + 更新缓存（+分布式锁）**、更新数据库 + 删除缓存，删除缓存+更新数据库
>
>   3. 如果是删除缓存+更新数据库（1）请求A进行写操作，删除缓存（2）请求B查询发现缓存不存在（3）请求B去数据库查询得到旧值（4）请求B将旧值写入缓存（5）请求A将新值写入数据库，就会导致缓存中一直都是旧值。所以采用更新数据库 + 删除缓存
>
>   4. 更新数据库 + 更新缓存方案，在并发场景下无法保证缓存和数据一致性，且存在缓存资源浪费、以及机器性能浪费的情况发生，所以推荐用 "先更新数据库，再删除缓存" 方案
>
>   5. 在 "先更新数据库，再删除缓存" 方案下，为了保证两步都成功执行，需配合消息队列或订阅变更日志的方案来做，本质是通过重试的方式保证数据一致性，可以将重试消息放入消息队列中去执行，或者类似阿里的canal去订阅mysql的binlog日志
>
>      > 1. 线程 A 读缓存，发现不存在
>      > 2. 线程 A 读取数据库，得到值（value = 1）
>      > 3. 线程 B 更新数据库（value = 2）
>      > 4. 线程 B 删除缓存
>      > 5. 线程 A 将旧值写入缓存（value = 1）
>      >
>      > 这种情况不太容易出现，因为更新数据库操作时间比较长，写入缓存时间比较短
>
>   6. 在 "先更新数据库，再删除缓存" 方案下，"读写分离 + 主从库延迟" 也会导致缓存和数据库不一致，缓解此问题的方案是凭借经验发送延迟消息到队列中，**延迟删除缓存**，同时也要控制主从库延迟，尽可能降低不一致发生的概率
>
>   7. 为了避免缓存击穿，如果删除的是热门数据，那么建议采用不直接删除，而是**设置一个较短的生命周期**。业务方在获取数据的时候，告诉它这是一个**旧数据脏数据**，是否使用由你来决定

为什么删除而不是更新？1.性能，缓存值可能会经过大量计算得到，更新的话就需要时间去计算 2.安全

先删除缓存，再更新数据库，那如何解决一致性问题呢？延迟双删

如果删除缓存失败怎办？补偿机制：1.重试2.订阅binlog

Redis在用作缓存时，使用**只读缓存或读写缓存**的哪种模式？

1、**只读缓存模式：**每次修改直接写入后端数据库，如果Redis缓存不命中，则什么都不用操作，如果Redis缓存命中，则删除缓存中的数据，待下次读取时从后端数据库中加载最新值到缓存中。

2、**读写缓存模式+同步直写策略**：由于Redis在淘汰数据时，直接在内部删除键值对，外部无法介入处理脏数据写回数据库，所以使用Redis作读写缓存时，只能采用同步直写策略，修改缓存的同时也要写入到后端数据库中，从而保证修改操作不被丢失。但这种方案在并发场景下会导致数据库和缓存的不一致，需要在特定业务场景下或者配合分布式锁使用。

当一个系统引入缓存时，需要面临最大的问题就是，如何保证缓存和后端数据库的一致性问题，最常见的3个解决方案分别是Cache Aside、Read/Write Throught和Write Back缓存更新策略。

1、**Cache Aside策略**：就是文章所讲的只读缓存模式。读操作命中缓存直接返回，否则从后端数据库加载到缓存再返回。写操作直接更新数据库，然后删除缓存。这种策略的优点是一切以后端数据库为准，可以保证缓存和数据库的一致性。缺点是写操作会让缓存失效，再次读取时需要从数据库中加载。这种策略是我们在开发软件时最常用的，在使用Memcached或Redis时一般都采用这种方案。

2、**Read/Write Throught策略**：应用层读写只需要操作缓存，不需要关心后端数据库。应用层在操作缓存时，缓存层会自动从数据库中加载或写回到数据库中，这种策略的优点是，对于应用层的使用非常友好，只需要操作缓存即可，缺点是需要缓存层支持和后端数据库的联动。

3、**Write Back策略**：类似于文章所讲的读写缓存模式+异步写回策略。写操作只写缓存，比较简单。而读操作如果命中缓存则直接返回，否则需要从数据库中加载到缓存中，在加载之前，如果缓存已满，则先把需要淘汰的缓存数据写回到后端数据库中，再把对应的数据放入到缓存中。这种策略的优点是，写操作飞快（只写缓存），缺点是如果数据还未来得及写入后端数据库，系统发生异常会导致缓存和数据库的不一致。这种策略经常使用在操作系统Page Cache中，或者应对大量写操作的数据库引擎中。

除了以上提到的缓存和数据库的更新策略之外，还有一个问题就是**操作缓存或数据库发生异常时如何处理**？例如缓存操作成功，数据库操作失败，或者反过来，还是有可能会产生不一致的情况。

比较简单的解决方案是，根据业务设计好更新缓存和数据库的先后顺序来降低影响，或者给缓存设置较短的有效期来降低不一致的时间。如果需要严格保证缓存和数据库的一致性，即保证两者操作的原子性，这就涉及到**分布式事务问题**了，常见的解决方案就是我们经常听到的**两阶段提交（2PC）、三阶段提交（3PC）、TCC、消息队列**等方式来保证了，方案也会比较复杂，一般用在对于一致性要求较高的业务场景中