## redis面试

###### redis使用场景

1. 缓存
2. session共享
3. 分布式锁
4. 计数器
5. 限流

1. **Redis底层的数据类型**

   字符串，*链表，字典*，跳跃表，整数集合，压缩列表，对象

2. redis实现的数据结构

   字符串，哈希，列表，集合，有序集合

3. redis底层实现的字符串SDS 和C语言的区别，SDS的优点。

4. redis链表的构造

   list表示链表，有头尾结点head和tail，复制函数dup，释放函数free,对比函数match，

   list包含多个listnode节点。

5. 字典的应用场景

6. 字典的具体实现

   字典由hash表(table,size,sizemask,used)实现，hash表有多个hash节点（key表示健,union值,next下一个节点）

   ![](assets/redis%E5%AD%97%E5%85%B8.jpg)

7. 哈希算法实现

8. 哈希冲突采用的什么方法

9. rehash操作

   随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。

   1.为字典的ht[1]哈希表分配空间，具体大小取决于操作====（扩展：ht[1]=第一个大于等于ht[0].used*2的2 n（2的n次方幂）收缩：ht[1]=第一个大于等于ht[0].used的2 n。）====

   2.将ht[0]上的健重新映射到ht[1]上

   3.释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表

   

10. 什么时候会进行rehash操作

   1）服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。（负载因子=use/size）

   2）服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。

   3)负载因子小于0.1时。执行收缩hash

11. 渐进式rehash

    采用rehashidx来记录已经rehash的个数，hash完成后rehashidx设为-1

    此外：**渐进式rehash的过程中，字典会使用两个哈希表，所以渐进式rehash期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行**

    #### 2021年03月17。

    -----------------------------------------------------------------

    

12. 跳跃表基本信息

    平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。

    有序集合包含的元素比较多，又或有序集合中成员是比较长的字符串，Redis就会使用跳跃表

    两个应用场景：1. 实现有序集合键 2. 在集群节点中用作内部数据结构。

    

13. 跳跃表怎么实现的

    zskiplist（header，tail，level，length）

    zskiplistNode结构

    zskiplist用于保存**跳跃表信息**（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示**跳跃表节点**。

    层，前进指针，跨度，后退指针

14. 整数集合

    encoding属性表示数组中整数类型，INTSET_ENC_INT16，INTSET_ENC_INT32，INTSET_ENC_INT64，contents中整数类型都是完全一致的。

15. 整数集合升级

    **不支持降级操作**，

16. ==压缩列表==

    列表键和哈希键的底层实现之一，列表里面都是小整数或者小字符串，

    压缩列表节点：previous_entry_length、encoding、content

17. ==压缩列表连锁更新的操作==

    添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高

18. Redis对象

    字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象

    每种对象都会用到一种或几种之前的数据结构

    对象系统实现了==基于引用计数的内存回收机制==以及==访问时间记录==

    每个键值对会有两个对象：键对象和值对象

    TYPE命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型

    OBJECT ENCODING命令可以查看一个数据库键的值对象的编码

    

19. 字符串对象

    字符串对象的编码可以是int、raw或者embstr。

    字符串长度大于32，使用raw来编码

    小于32使用emstr来编码，保存短字符串

    raw和emstr编码的区别；

20. embstr编码的优势

    #### 2021年03月18日

    ------------------------------------------------------------

    

21. 列表对象

    使用ziplist或者linkedlist作为底层实现，

    ==列表对象使用什么编码==？：1.列表对象保存的元素的长度小于64字节；2.列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。

22. 哈希对象

    使用ziplist或者hashtable作为底层编码，

    使用压缩列表怎么存储的？

    使用hashtable怎么存储的？

    当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：❑哈希对象保存的所有键值对的键和值的字符串长度都==小于64字节==；❑哈希对象保存的键值对数量==小于512个==；不能满足这两个条件的哈希对象需要使用hashtable编码。·

23. 集合对象

    集合对象的编码可以是intset（整数集合）或者hashtable（字符串）。

    当集合对象可以同时满足以下两个条件时，对象使用intset编码：❑集合对象保存的所有元素都是==整数值==；❑集合对象保存的元素数量==不超过512个==

24. 有序集合对象

    有序集合的编码可以是ziplist或者skiplist（zset）。

    当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：❑有序集合保存的元素数量==小于128个==；❑有序集合保存的所有元素成员的长度都==小于64字节==

25. 为什么有序集合需要同时使用跳跃表和字典来实现？

26. redis的类型检查

    而另一种命令只能对特定类型的键执行，比如说：

    ❑SET、GET、APPEND、STRLEN等命令只能对字符串键执行；

    ❑HDEL、HSET、HGET、HLEN等命令只能对哈希键执行；

    ❑RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行；

    ❑SADD、SPOP、SINTER、SCARD等命令只能对集合键执行；

    ❑ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键执行；

    在执行命令之前，会先进行类型检查，正确才会执行，错误则会报错。

    还会根据底层编码方式进行命令选择，或者说大部分执行命令数多态的，可以进行选择的。

    DEL、EXPIRE等命令和LLEN等命令的区别在于，前者==是基于类型的多态==——一个命令可以同时用于处理多种不同类型的键，而后者是==基于编码的多态==——一个命令可以同时用于处理多种不同编码。

27. redis内存回收

    也就是基于引用计数器，可以进行对象共享，空转时长（记录最后一次访问时长）可以帮助内存回收。

    Redis会共享值为0到9999的字符串对象。

28. 为什么Redis不共享包含字符串的对象？

    #### 2021年03月20

    ------------------------------------------

    

29. Redis数据库

    redisServer下面有db数组，每个db数组有redisDb代表不同数据库，默认有16个

    SELECT命令可以用于切换数据库

    增删改查键值对SET ,DEL,SET,GET,

    SETEX命令可以在设置一个字符串键的同时为键设置过期时间,是一个字符串命令

    TTL命令和PTTL命令接受有生存时间或者过期时间的键，返回键的剩余生存时间

30. Redis设置键的过期时间

    EXPIRE，PEXPIRE,EXPIREAT,PEXPIREAT设置过期时间

    redis中有过期字典可以保存过期时间

    PERSIST命令可以移除一个键的过期时间

    is_expired函数检查是否过期

31. 如何检查键是否过期

32. 过期键删除策略

    定时删除，惰性删除，定期删除

33. 定期删除策略

    activeExpireCycle函数被调用，规定的时间内，分多次遍历服务器中的数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。

    #### 2021年03月21

    --------------------------------

    

34. RDB持久化和AOF持久化区别，优缺点

    RDB优点：

    - 如果要进行大规模数据的恢复，RDB方式要比AOF方式恢复速度要快。
    - RDB可以最大化Redis性能，父进程做的就是fork子进程，然后继续接受客户端请求，让子进程负责持久化操作，父进程无需进行IO操作。
    - RDB是一个非常紧凑(compact)的文件,它保存了某个时间点的数据集，非常适合用作备份，同时也非常适合用作灾难性恢复，它只有一个文件，内容紧凑，通过备份原文件到本机外的其他主机上，一旦本机发生宕机，就能将备份文件复制到redis安装目录下，通过启用服务就能完成数据的恢复。

    RDB缺点：

    - RDB这种持久化方式不太适应对数据完整性要求严格的情况，因为，尽管我们可以用过修改快照实现持久化的频率，但是要持久化的数据是一段时间内的整个数据集的状态，如果在还没有触发快照时，本机就宕机了，那么对数据库所做的写操作就随之而消失了并没有持久化本地dump.rdb文件中。
    - 每次进行RDB时，父进程都会fork一个子进程，由子进程来进行实际的持久化操作，如果数据集庞大，那么fork出子进程的这个过程将是非常耗时的，就会出现服务器暂停客户端请求，将内存中的数据复制一份给子进程，让子进程进行持久化操作

    AOF优点：

    - AOF有着多种持久化策略：
      appendfsync always:每修改同步，每一次发生数据变更都会持久化到磁盘上，性能较差，但数据完整性较好。appendfsync everysec: 每秒同步，每秒内记录操作，异步操作，如果一秒内宕机，有数据丢失。appendfsync no:不同步。
- AOF文件是一个只进行追加操作的日志文件，对文件写入不需要进行seek，即使在追加的过程中，写入了不完整的命令（例如：磁盘已满），可以使用redis-check-aof工具可以修复这种问题
    - Redis可以在AOF文件变得过大时，会自动地在后台对AOF进行重写：重写后的新的AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis在创建AOF文件的过程中，会继续将命令追加到现有的AOF文件中，即使在重写的过程中发生宕机，现有的AOF文件也不会丢失。一旦新AOF文件创建完毕，Redis就会从旧的AOF文件切换到新的AOF文件，并对新的AOF文件进行追加操作。
- AOF文件有序地保存了对数据库执行的所有写入操作。这些写入操作Redis协议的格式保存，易于对文件进行分析；例如，如果不小心执行了FLUSHALL命令，但只要AOF文件未被重写，通过停止服务器，移除AOF文件末尾的FLUSHALL命令，重启服务器就能达到FLUSHALL执行之前的状态。

AOF缺点：

- 对于相同的数据集来说，AOF文件要比RDB文件大。

- 根据所使用的持久化策略来说，AOF的速度要慢与RDB。一般情况下，每秒同步策略效果较好。不使用同步策略的情况下，AOF与RDB速度一样快。

35. RDB文件

    创建：SAVE和BGSAVE（创建子进程去处理）。

    自动载入，如果AOF开启，则优先处理AOF

    saveparams数组设置了多个saveparam格式的保存状态

    dirty计数器和lastsave属性

    每隔100ms调用serverCron来检查是否满足save条件

36. RDB文件的格式

    REDIS,db_version,databases,EOF,check_sum

    database部分有：SELECTDB、db_number、==key_value_pairs==三个部分

    key_value_pairs：TYPE（1字节记录value类型）、key、value；不同type类型的键保存格式不同

    对不同类型value存储形式也不同

37. od命令分析RDB文件

    od -c命令；RDB文件检查工具：redis-check-dump

38. 有关持久化的资料

    http://blog.nosqlfan.com/html/3813.html

    #### 2021年03月22日

    -------------------------------

39. AOF持久化

    RDB写数据，AOF写命令；

    AOF持久化功能的实现可以分为命令==追加（append）==、==文件写入==、==文件同步（sync）==

    系统提供fsync和fdatasync同步函数，可以强制操作系统立即将缓冲区中的数据写入到硬盘里面

    

40. 读取AOF文件并还原过程

    1.创建一个不带网络连接的伪客户端（fake client）2. 从AOF文件中分析并读取出一条写命令。3）使用伪客户端执行被读出的写命令。4）一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止

41. AOF重写原理

    从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。

    1) 创建新的AOF 2)写入select命令3)进行遍历4)忽略过期键5) 对键进行重写（先取值，再使用set命令来定值）

    为了避免重写时会阻塞服务器，redis使用子进程来重写AOF

42. 使用子进程重写时发生了数据的修改怎么处理

    为了解决这种数据不一致问题，Redis服务器设置了一个**AOF重写缓冲区**，这个缓冲区在服务器**创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区**

    #### 2021年03月23

    --------------------------

43. 文件事件处理器

    套接字、I/O多路复用程序、文件事件分派器（dispatcher），事件处理器

    通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。

44. 客户端

    redis通过**链表**来保存所有客户端的状态信息，

    客户端状态的**fd属性**记录了客户端正在使用的套接字描述符

    客户端的标志属性flags记录了客户端的角色（role）

    客户端状态的输入缓冲区用于保存客户端发送的命令请求

45. 客户端的连接与关闭

    硬性限制，软性限制

     Lua脚本的伪客户端（一直存在）

46. serverCron函数

    serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。（例如 1)更新服务器时间缓存,2)更新LRU时钟3)更新服务器每秒执行命令次数4. 更新服务器内存峰值记录5.处理SIGTERM信号6.管理客户端资源7. 管理数据库资源8. 执行被延迟的BGREWRITEAOF 9. 检查持久化操作的运行状态10.将AOF缓冲区中的内容写入AOF文件11. 增加cronloops计数器的值）

    lru属性保存了对象最后一次被命令访问的时间,用于计算值对象的空转时长，

    服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小：

47. 初始化服务器步骤

    1 初始化状态变量，设置各个属性（运行id，端口号）

    2  载入配置选项

    3 初始化服务器数据结构

    4 还原数据库

    5 执行时间循环

    #### 2021年03月25日

    -------------------

    

48. 同步和命令传播

49. PSYNC命令的实现的完整过程

    初始复制->网络中断–>重新从中断处复制

50. 复制功能实现的完整步骤

51. REPLCONF ACK心跳检测

    检测主从服务器的网络连接状态，辅助实现min-slaves选项，检测命令丢失

52. redis 的Sentinel系统

    由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求，

    1).启动Sentinel系统，也就是初始化一个普通的redis服务器，不过不用执行持久化文件

    2).使用Sentinel专用代码，PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和PUNSUBSCRIBE这七个命令就是客户端可以对Sentinel执行的全部命令

    3).初始化Sentinel状态的masters属性

    4).创建连向主服务器的网络连接（命令连接，订阅连接）

    #### 2021年03月30日

    --------------

    

53. 选举领头Sentinel

    （高可用方案）

    Sentinel系统选举领头Sentinel的方法是对==Raft算法的领头选举==方法的实现

54. 新的主服务器是怎样挑选出来的

55. redis集群

    redis集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。

    槽指派、命令执行、重新分片、转向、故障转移、消息

    通过CLUSTER MEET命令进行握手

    集群数据结构：1.clusterNode结构保存了一个节点的当前状态。clusterLink，clusterState

56. 槽指派

    

57. 

58. Redis主从复制功能和实现原理

    #### 2021年03月31日

    -----------

    

59. Redis的LRU策略，定期删除策略

60. Redis哨兵，主从同步

    客户端每次先访问Sentinel节点，寻找master节点的地址，然后再去访问master节点，并不断监控主节点，如果主节点宕机了，则Sentinel会立即更换主节点的地址

    > Sentinel主节点更换客户端如何感知？？
    >
    > 1. 连接池建立新连接时，会去查询主库地址，然后跟内存中的主库地址进行比对，如果变
    >    更了，就断开所有连接，重新使用新地址建立新连接。如果是旧的主库挂掉了，那么所有正
    >    在使用的连接都会被关闭，然后在重连时就会用上新地址。
    > 2. 如果不在建立新的连接，也可以更换地址，在执行修改性命令的时候会捕获了一个特殊的异常 ReadOnlyError，这个异常会把所有的旧连接给关闭

    CAP理论：网络分区发生时，一致性和可用性两难全，但保持**最终一致性**；

    redis支持主从同步和**从从同步**，增量同步，快照同步，无盘复制，

    

61. **Redis分布式锁**

    https://www.zhihu.com/question/300767410?sort=created

    之前获取锁用 `setnx`（set if not exists） 指令，只允许被一个客户端占坑。先来先占，调用 del 指令释放“坑”。

    Redis2.8后面可以使用set指令，`set XXX true ex 5nx` 获取锁和设置过期时间指令一同执行

62. **异步队列**

    

63. **Redis实现限流**

    1. 使用zset维护一个时间窗口，记录时间窗口中的数据，（Redis的流水线Pipelined）
    2. 漏斗限流算法
    3. 令牌桶算法（redis-cell模块）

64. 位图

65. 统计用户UV(HyperLogLog)

66. 布隆过滤器以及布谷鸟过滤器

    布谷鸟过滤器：https://juejin.cn/post/6844903861749055502

67. scan

    

68. 优雅使用jedis

    jedis就是将Redis封装起来对外提供调用接口来操控redis的一个工具。

    使用redis池 jedisPool，需要使用完毕关闭连接，**在catch中增加重试机制**

    jedis的完整的封装代码：

69. 保护Redis

    Redis 有一些非常危险的指令，比如 **keys 指令会导致 Redis 卡顿**，**flushdb 和 flushall 会让 Redis 的所有数据全**
    **部清空**

    1. rename-command 指令用于将某些危险的指令修改成特别的名称，用来避免人为误操作。改名成空串就相当于禁用

    2. Redis 的密码访问限制
    3. Redis 并不支持 SSL 链接，需要使用ssl代理来提供远程连接，spiped工具

70. 

71. 

72. 

    