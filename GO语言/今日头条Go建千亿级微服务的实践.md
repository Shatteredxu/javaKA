## 今日头条Go建千亿级微服务的实践



##### Go语言天然优势：

语法简单，上手快 性能高，编译快，开发效率也不低 原生支持并发，协程模型是非常优秀的服务端模型，同时也适合网络调用

部署方便，编译包小，几乎无依赖。

##### 微服务架构

Go 语言研发了内部的微服务框架 kite，协议上完全兼容 Thrift，集成了服务注册和发现，分布式负载均衡，超时和熔断管理，服务降级，Method 级别的指标监控，分布式调用链追踪

##### 并发

基于用户态并发，属于 CSP 并发模型的一种实现，CSP 并发模型的核心概念是：“不要通过共享内存来通信，而应该通过通信来共享内存”。这在 Go 语言中的实现就是 Goroutine 和 Channel。在1978发表的 CSP 论文中有一段使用 CSP 思路解决问题的描述。

两种并发控制方式Wait和Cancel：等待这调用的返回结果，是 Wait ；模式超时取消使用Cannel；在 Go 语言中，分别有 sync.WaitGroup 和 context.Context 来实现这两种模式。

##### 超时控制

在 kite 框架中引入了并发超时控制的概念，并将功能集成到 kite 框架的客户端调用库中。

***具体流程：***客户端发起 RPC 请求，经过“Concurrent Ctrl”模块判断是否允许当前请求发起。如果被允许发起 RPC 请求，此时启动一个协程并执行 RPC 调用，同时初始化一个超时定时器。然后在主协程中同时监听 RPC 完成事件信号以及定时器信号。如果 RPC 完成事件先到达，则表示本次 RPC 成功，否则，当定时器事件发生，表明本次 RPC 调用超时。这种模型确保了无论何种情况下，一次 RPC 都不会超过预定义的时间，实现精准控制超时。

##### 性能

Go 语言工具链中自带了多种性能分析工具：

CPU 使用分析

内部使用分析

查看协程栈

查看 GC 日志

Trace 分析工具

总结一些优化方法：

- 可以使用 CAS，则使用 CAS 操作
- 针对热点代码要做针对性优化
- 不要忽略 GC 的影响，尤其是高性能低延迟的服务
- 合理的对象复用可以取得非常好的优化效果
- 尽量避免反射，在高性能服务中杜绝反射的使用
- 有些情况下可以尝试调优“GOGC”参数
- 新版本稳定的前提下，尽量升级新的 Go 版本，因为旧版本永远不会变得更好

##### 一次优化过程

1. 找到问题点：

   > - GC 压力大，占用 CPU 资源高
   > - 反序列化过程占用 CPU 较高

   2.确定优化思路

   > - GC 压力主要是内存的频繁申请和释放，因此决定减少内存和对象的申请
   > - 序列化当时使用的是 Thrift 序列化方式，通过 Benchmark，我们找到相对高效的 Msgpack 序列化方式。
   > - 避免频繁的 Buffer 申请和释放，使用“sync.Pool”实现了一个对象池，达到对象复用的目的。
   > - 

