应用程序的内存一般会分成<u>堆区和栈区</u>，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收，那么栈空间应该如何管理呢？

##### 设计原理

栈区的内存一般由编译器自动分配和释放，其中存储着函数的入参以及局部变量。这些参数会随着函数的创建而创建，函数的返回而消亡，一般不会在程序中长期存在，这种线性的内存分配策略有着极高地效率。

**栈寄存器**是 CPU 寄存器中的一种，它的主要作用是跟踪函数的调用栈，Go 语言的汇编代码包含 <u>BP 和 SP 两个栈寄存器</u>，它们分别存储了栈的**基址指针**和**栈顶的地址**，栈内存与函数调用的关系非常紧密，我们在函数调用一节中曾经介绍过栈区，BP 和 SP 之间的内存就是当前函数的调用栈。

线程栈：在 Linux 操作系统中执行 `pthread_create` 系统调用，进程会启动一个新的线程，如果用户没有通过软资源限制 `RLIMIT_STACK` 指定线程栈的大小，那么操作系统会根据架构选择不同的默认栈大小。多数架构上默认栈大小都在 2 ~ 4 MB 左右，极少数架构会使用 32 MB 的栈，用户程序可以在分配的栈上存储函数参数和局部变量。

悬挂指针：当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的**内存地址**



##### 逃逸分析

逃逸分析是用来决定指针<u>动态作用域</u>的方法。Go 语言的编译器使用逃逸分析<u>决定哪些变量应该在栈上分配，哪些变量应该在堆上分配</u>，其中包括使用 `new`、`make` 和字面量等方法隐式分配的内存，Go 语言的逃逸分析遵循以下两个不变性：

1.  指向栈对象的指针不能存在于堆中；
2.  指向栈对象的指针不能在栈对象回收后存活；

