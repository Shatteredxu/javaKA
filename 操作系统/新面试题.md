### 相比 32 位，64 位的优势是什么？

* 如果是软件，那么我们的数据库有 32 位和 64 位版本；

* 如果是操作系统，那么在阿里云上选择 Centos 和 Debian 版本的时候，也会有 32/64 版本；

* 如果是 CPU，那么有 32 位 CPU，也有 64 位 CPU能计算 64位更大的数字

  参考：https://blog.csdn.net/weixin_37841366/article/details/112093958


##### **64 位宽 CPU**

* 如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；
* 如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。

这里的 32 和 64，称作 CPU 的位宽。

CPU 位数越大，可以计算的数值就越大，但是 32 位 CPU 能计算的最大整数是 4294967295，这已经很大了

CPU 的位宽：通常 32 位宽 CPU 最多操作 32 位宽的地址总线和数据总线。

> 1.  可以执行更大数字的运算，这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显。
> 2. 64 位 CPU 可以寻址更大的内存空间

##### **64 位的程序**

> * 32 位指令在 64 位机器上执行，困难不大，可以兼容。 如果是 64 位指令，在 32 位机器上执行就困难了。因为 32 位指令在 64 位机器执行的时候，需要的是一套***\*兼容机制\****；
> * 但是 64 位指令在 32 位机器上执行，***\*32 位的寄存器都存不下指令的参数。\****

##### 64位的操作系统

> 操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上

### 进程调度算法

先来先服务：FCFS 对⻓作业有利，适⽤于 CPU 繁忙型作业的系统，⽽不适⽤于 I/O 繁忙型作业的系统。

**最短作业优先调度算法**：对⻓作业不利

**⾼响应⽐优先调度算法**：**每次进⾏进程调度时，先计算「响应⽐优先级」，然后把「响应⽐优先级」最⾼的进程投⼊运⾏**，「响应

⽐优先级」的计算公式：（等待时间+要求服务时间）/要求服务时间 ，等待时间越长，优先级越高

**时间⽚轮转调度算法**：如果时间⽚设得太短会导致过多的进程上下⽂切换，降低了 CPU 效率；如果设得太⻓⼜可能引起对短作业进程的响应时间变⻓。

最⾼优先级调度算法：从就绪队列中选择最⾼优先级的进程进⾏运⾏，这称为最⾼优先级（**Highest Priority First*，****HPF****）调度算法**。

多级反馈队列调度算法

### 页面置换算法

当 CPU 访问的⻚⾯不在物理内存时，便会产⽣⼀个缺⻚中断，请求操作系统将所缺⻚调⼊到物理内存。那它与⼀般中断的主要区别在于：

1.   缺⻚中断在指令执⾏「期间」产⽣和处理中断信号，⽽⼀般中断在⼀条指令执⾏「完成」后检查和处理中断信号。

2.   缺⻚中断返回到该指令的开始重新执⾏「该指令」，⽽⼀般中断返回回到该指令的「下⼀个指令」执⾏。

最佳⻚⾯置换算法（*OPT*）：**置换在「未来」最⻓时间不访问的⻚⾯**。

先进先出置换算法（*FIFO*）：选择在内存驻留时间很⻓的⻚⾯进⾏中置换

最近最久未使⽤的置换算法（*LRU*）选择最⻓时间没有被访问的⻚⾯进⾏置换

时钟⻚⾯置换算法（*Lock*）：

最不常⽤置换算法（*LFU*）：**选择「访问次数」最少的那个⻚⾯，并将其淘汰**

### 磁盘调度算法

先来先服务算法

最短寻道时间优先算法

扫描算法算法

循环扫描算法

LOOK 与 C-LOOK 算法

