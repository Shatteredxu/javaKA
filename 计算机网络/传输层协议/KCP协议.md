KCP协议
-------

kcp-c源码解析–https://luyuhuang.tech/2020/12/09/kcp.html

kcp-go解析–https://www.cnblogs.com/zhangboyu/p/34c07c3577c85e9ae5c3477d7cab5f52.html

kcp源码–https://github.com/skywind3000/kcp

#### 简介

KCP协议是在UDP协议以上实现了一套完整的ARQ可靠协议，能达到比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果，但是它不负责底层协议（像TCP,UDP）的收发，所以需要使用者自动去选择下层数据包的收发方式。连时钟都需要外部传递进来，内部不会有任何一次系统调用。

#### 核心特性

KCP有正常模式和快速模式两种，通过以下策略达到提高流速的结果

1.   RTO翻倍vs不翻倍：TCP超时计算是RTOx2，而KCP启动快速模式后不x2，只是x1.5
2.   选择性重传 vs 全部重传：TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。
3.   快速重传：KCP中有一个una字段，表示该报文发送者的接收缓冲区中最小还未收到的报文编号，通过每个ack中的una字段就可以快速判断哪个字段出现了丢失
4.   延迟ACK vs 非延迟ACK：TCP为了充分利用带宽，延迟发送ACK，这样会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。
5.   UNA vs ACK+UNA：ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。
6.   非退让流控：KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率

### 发送，接受与重传

### 拥塞控制

初始 cwnd 设为 1, 随后平均每经过一个 RTT 时间 cwnd 都翻一倍, 达到**慢启动阈值(Slow Start Threshold)**, 通常记作 ssthresh后进行线性增长。随着cwnd 的增长, 网路容量会被逐步填满，会不可避免地出现丢包. 这就意味着我们的发送速率过大, cwnd 应该减小了. KCP 称之为**丢包退让**. 

此时有两种策略: 1. 一种是将 <u>ssthresh 置为当前 cwnd 的一半</u>, 然后 cwnd 置为 1, 重新执行**慢启动**; 

​							  2. 另一种也会将 ssthresh 置为当前 cwnd 的一半, 但 cwnd 置为比 ssthresh 稍高的值, 然后进入**快速恢复**阶段. 快速恢复阶段中, cwnd 会以与拥塞避免相同的方式线性增长. KCP 采用的策略是, 如果发生<u>超时重传, 就进入慢启动; 如果发生快速重传, 就进入快速恢复</u>.

#### 慢启动



#### 拥塞控制

在TCP中，达到慢启动阈值之后，每经过一个RTT,cwnd就进行线性增加，直到出现丢包

在 KCP 的实现中, 拥塞避免阶段的 cwnd 仍然会在每收到一个 ACK 的时候增长, 只不过不是增加 1, 而是增加零点几. KCP 的做法是维护一个中间变量 incr, 其含义可以认为是 cwnd 的 mss 倍. 在拥塞避免阶段, 每收到一个 ACK, incr 都会以如下方式增长:$i n c r \leftarrow i n c r+\frac{m s s^{2}}{i n c r}+\frac{m s s}{16}$，然后当 incr 累计增加的值超过一个 mss 时, cwnd 增加 1, 保持 incr 与 cwnd 之间的倍数关系. 





#### 快恢复

