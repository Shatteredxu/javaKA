HTTP 的一些缺点，“无状态”可以加入 Cookie ，“明文”和“不安全”仅凭 HTTP 自身是无力解决的，需要引入新的 HTTPS 协议。具备安全需要满足四个特性：**机密性、完整性，身份认证和不可否认**

<u>机密性：</u>发送的内容不能被其他人截获，比如使用Wireshark就可以看到HTTP的报文—（秘钥加密）

<u>完整性：</u>数据在传输过程中没有被窜改，不多也不少，“完完整整”地保持着原状。—（摘要算法）

<u>身份认证：</u>确认对方的真实身份，将信息发送给正确的人

<u>不可否认：</u>需要对传输一个数字签名，这个签名不能由其他人伪造，就像盖章，本人签字一样。

### SSL/TLS

SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，将其改名为TLS也就是TLS1.0,目前应用的最广泛的 TLS/1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的，

TLS 由**记录协议**、**握手协议**、警告协议、**变更密码规范**协议、扩展协议等几个子协议组成，综合使用了**对称加密**、非对称加密、**身份认证**等许多密码学前沿技术。

<img src="assets/TLS密码套件.png" alt="TLS密码套件" style="zoom:43%;" />

密码套件：密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法,上面的suite就是server端的密码套件

**OpenSSL**，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议

### 对称加密和非对称加密

##### 对称加密

加密解密的秘钥是一样的，常用的对称加密算法，比如 RC4、DES、3DES、AES、ChaCha20 等，目前只有AES 和 ChaCha20是安全的，

**AES** 的意思是“高级加密标准”（Advanced Encryption Standard），密钥长度可以是 128、192 或 256。它是 DES 算法的替代者，安全强度很高，性能也很好，而且<u>有的硬件还会做特殊优化</u>，是应用最广泛的对称加密算法。

**ChaCha20** 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，现在不再具有明显的优势，但仍然算得上是一个不错算法。

##### 加密分组模式

“**分组加密模式**”可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文）。

最早有 ECB、CBC、CFB、OFB 等几种分组模式，但都陆续被发现有安全漏洞，现在基本都不怎么用了。最新的分组模式被称为 <u>AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。</u>

##### 非对称加密

非对称加密可以解决对称加密算法的“密钥交换”的问题，

它有两个密钥，一个叫“**公钥**”（public key），一个叫“**私钥**”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。公钥和私钥有个特别的“**单向**”性，公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。

非对称加密算法有 DH、DSA、RSA、ECC 等。RSA 可能是其中最著名的一个，但现在的RSA1024已经不安全，需要使用2048位才能保证安全。

##### 混合加密

由于非对称加密需要大量的数学计算，所以其速度很慢，即使是 ECC 也要比 AES 差上好几个数量级。如果仅用非对称加密，虽然保证了安全，但是速度太慢。所有 现在基本都是使用混合加密–使用非对称加密传递对称加密的秘钥。这样混合加密就<u>解决了对称加密算法的密钥交换问题</u>，也就是目前TLS中使用的加密模式

### 摘要算法和数字签名

##### 摘要算法

使用混合加密解决了机密性问题，接着还有完整性，身份认证等特性才能实现真正的安全。

实现完整性的手段主要是**摘要算法**，也就是常说的散列函数、哈希函数（Hash Function），摘要算法把数据从一个“大空间”映射到了“小空间”，所以我们需要一个好的hash算法来避免冲突。常见的摘要算法有：MD5,SHA-1,SHA-2

LS 推荐使用的是 SHA-1 的后继者：SHA-2。SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。

##### 数字签名

加密算法结合摘要算法，我们的通信过程可以说是比较安全了。但这里还有漏洞，就是通信的两个端点（endpoint）。黑客可以伪装成网站来窃取信息。而反过来，他也可以伪装成你，向网站发送支付、转账等消息，网站没有办法确认你的身份，钱可能就这么被偷走了。

非对称加密里的“**私钥**”，使用私钥再加上摘要算法，就能够实现“**数字签名**”，同时实现“身份认证”和“不可否认”。

##### 数字证书和 CA

还有一个“**公钥的信任**”问题。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么来判断这个公钥就是你或者某宝的公钥呢？所以就有了第三方机构CA, 小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是**Root CA**，就只能自己证明自己了，这个就叫“**自签名证书**”（Self-Signed Certificate）或者“**根证书**”（Root Certificate）

### TLS1.2连接过程

HTTPS 建立连接:在HTTP建立连接后，还需要TLS握手，两个握手都结束后，才可以进行数据的发送。

 TLS 包含几个子协议，比较常用的有<u>记录协议</u>、<u>警报协议</u>、<u>握手协议</u>、<u>变更密码规范协议</u>等。

**记录协议**（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。

**警报协议**（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。

**握手协议**（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。

最后一个是**变更密码规范协议**（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。

<img src="assets/TLS握手过程.png" alt="TLS握手过程" style="zoom:67%;" />

1.   客户端发送一个“**Client Hello**”消息，里面有客户端的版本号、支持的密码套件，还有一个**随机数（Client Random）**，用于后续生成会话密钥。
2.   服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个**随机数（Server Random）**，然后从客户端的列表里选一个作为本次通信使用的密码套件
3.   服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）
4.   在证书后发送“**Server Key Exchange**”消息，里面是**椭圆曲线的公钥（Server Params）**，用来实现密钥交换算法，再加上自己的私钥签名认证。
5.   客户端这时也拿到了服务器的证书，开始走证书链逐级验证，确认证书的真实性，再用证书公钥验证签名，就确认了服务器的身份，
6.   客户端按照密码套件的要求，也生成一个**椭圆曲线的公钥（Client Params）**，用“**Client Key Exchange**”消息发给服务器
7.   客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法算出了一个新的东西，叫“**Pre-Master**”
8.   客户端服务器手里有了三个随机数：**Client Random、Server Random 和 Pre-Master**。用这三个作为原始材料，可以生成用于加密会话的主密钥，叫“**Master Secret**”
9.   有了主密钥和派生的会话密钥，握手就快结束了。客户端发一个“**Change Cipher Spec**”，然后再发一个“**Finished**”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。
10.   服务器也是同样的操作，发“**Change Cipher Spec**”和“**Finished**”消息，双方都验证加密解密 OK

由上，我们可以看到建立TLS连接需要2RTT,想要减少连接过程，我们就可以使用TLS1.3

### TLS1.3特性解析

TLS1.3 终于在2018 年“粉墨登场”，再次确立了信息安全领域的新标准。三个主要改进目标：**兼容**、**安全与性能**。

##### 兼容性

使用一个新的**扩展协议**（Extension Protocol）通过在记录末尾添加一系列的“扩展字段”来增加新的功能，老版本的 TLS 不认识它可以直接忽略，这就实现了“后向兼容”。在记录头的 Version 字段被兼容性“固定”的情况下，只要是 TLS1.3 协议，<u>握手的“Hello”消息后面就必须有“**supported_versions**”扩展</u>，它标记了 TLS 的版本号，使用它就能区分新旧协议。



##### 安全

废除了一些不安全的加密算法，TLS1.3 里只保留了 AES、ChaCha20 对称加密算法，分组模式只能用 AEAD 的 GCM、CCM 和 Poly1305，摘要算法只能用 SHA256、SHA384，密钥交换算法只有 ECDHE 和 DHE，椭圆曲线也被“砍”到只剩 P-256 和 x25519 等 5 种。现在的 TLS1.3 里只有 5 个套件，无论是客户端还是服务器都不会再犯“选择困难症”了。

##### 提升性能

HTTPS 建立连接时除了要做 TCP 握手，还要做 TLS 握手，在 1.2 中会多花两个消息往返（2-RTT），可能导致几十毫秒甚至上百毫秒的延迟，在移动网络中延迟还会更严重。TLS1.3 压缩了以前的“Hello”协商过程，删除了“Key Exchange”消息，把握手时间减少到了“1-RTT”，效率提高了一倍。

如何做到的？

1.   客户端在“Client Hello”消息里直接用“**supported_groups**”带上支持的曲线，比如 P-256、x25519，用“**key_share**”带上曲线对应的客户端公钥参数，用“**signature_algorithms**”带上签名算法。
2.   服务器收到后在这些扩展里选定一个曲线和参数，再用“key_share”扩展返回服务器这边的公钥参数，就实现了双方的密钥交换，后面的流程就和 1.2 基本一样了。

### HTTPS优化

<img src="assets/HTTPS耗时操作.png" alt="HTTPS耗时操作" style="zoom:37%;" />

##### 硬件优化

开启AES硬件优化，**SSL 加速服务器**（使用专门的服务器集群）

##### 软件优化

Linux 内核由 2.x 升级到 4.x，把 Nginx 由 1.6 升级到 1.16，把 OpenSSL 由 1.0.1 升级到 1.1.0/1.1.1。

##### 协议优化

1.   TLS1.3握手只需要1RTT
2.   密钥交换协议应当尽量选用椭圆曲线的 ECDHE 算法而不是RSA
3.   椭圆曲线也要选择高性能的曲线，最好是 x25519，次优选择是 P-256
4.   对称加密算法方面，也可以选用“AES_128_GCM”，它能比“AES_256_GCM”略快一点点。

##### 证书优化

客户端在验证证书的时候会走证书链逐级验证，验证的过程不仅需要「用 CA 公钥解密证书」以及「用签名算法验证证书的完整性」，而且为了知道证书是否被 CA 吊销，客户端有时还会再去访问 CA， 下载 CRL 或者 OCSP 数据，以此确认证书的有效性。这个访问过程是 **HTTP 访问**，因此又会产生一系列网络通信的开销，如 DNS 查询、建立连接、收发数据等。

**CRL列表内容**都是被撤销信任的证书序号，如果服务器的证书在此列表，就认为证书已经失效，不在的话，则认为证书是有效的，存在两个问题：1.实时性较差2，随着吊销证书的增多，列表会越来越大，下载的速度就会越慢。

OCSP：在线证书状态协议，**向 CA 发送查询请求，让 CA 返回证书的有效状态**，但是在线查询还是需要看网络时延，服务器响应快慢等问题

OCSP Stapling：服务器向 CA 周期性地查询证书状态，获得一个带有时间戳和签名的响应结果并缓存它。



##### 会话复用

TLS 握手协商出会话密钥，也就是对称加密密钥，我们可以把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，就可以减少 TLS 握手的性能损耗。

会话复用两种：Session ID，Session Ticket

Session ID 的工作原理是，**客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识**，缺点就是1. 服务器需要保存每一个客户端的会话密钥，随着客户端的增多，**服务器的内存压力也会越大**。2. 服务器可能由负载均衡服务器提供，可能选择不到上次访问的服务器。

 Session Ticket，服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端，客户端存储秘钥，在访问时带上秘钥，服务器只需要验证秘钥的有效性即可。
