动态代理
--------

推荐视频：https://www.bilibili.com/video/BV1cz41187Dk?from=search&seid=11976797762828396485&spm_id_from=333.337.0.0

### 1.静态代理



### 2.动态代理

***基于接口实现：***JDK实现的动态代理

***基于子类实现***：Cglib代理

##### 代理模式



#### JDK动态代理

***newProxyInstance三个参数：ClassLoader, Class<?>[], Invocationhandler***

ClassLoader: **用于加载JDK生成的代理类的类加载器**；

Class<?>[]：**代理类实现的接口**，即被代理的对象实现的接口，不同于继承，一个类可以实现多个接口，因此interfaces参数是一个Class类型的数组；

Invocationhandler：**代理类**，每个代理类的方法调用处理程序都必须实现InvocationHandler接口，当我们通过代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口的实例的invoke方法来调用。

***InvocationHandler的invoke方法***

proxy：代理对象，即JDK创建的动态代理类的实例，这个参数一般用不到

method：调用的方法，method是通过反射拿到的；

method：调用的方法，method是通过反射拿到的；

#### CGLib动态代理

使用CGLib库，可以实现无接口式的动态代理，相比JDK动态代理增强了功能

Cglib通过使用**ASM框架**操作字节码控制对象的访问，提供方法拦截操作，它可以在运行期扩展Java类与实现Java接口，不仅可以实现基于接口的动态代理也可实现基于子类的动态代理

### 3. 实战动态代理

#### 手写实现JDK动态代理

未调试成功：https://www.cnblogs.com/shoshana-kong/p/9110612.html

#### 手写实现CGLib动态代理



### 4. 总结

```java
package com.xwj;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class proxyDemo {


}
interface Speaker{
    public void speak();
}
class Zhangsan implements Speaker{

    @Override
    public void speak() {
        System.out.println("我要离婚");
    }
}
class Lisi {
//    没有实现接口的类
    public void speak() {
        System.out.println("我要离婚");
    }
}
class ZhangsanLawyer implements Speaker{
    private Zhangsan zhangsan = new Zhangsan();
    @Override
    public void speak() {
        System.out.println("应用法律条文");
        zhangsan.speak();
        System.out.println("道德谴责");
    }
}
class LawyerProxy implements InvocationHandler{
    private Object obj ;

    public LawyerProxy(Object obj) {//动态传入代理对象
        this.obj = obj;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        if(method.getName().equals("speak")){
            System.out.println("应用法律条文");
            method.invoke(obj,args);
            System.out.println("道德谴责");
        }
        return null;
    }
}
//cglib代理需要实现MethodInterceptor
class lawyerInteceptor implements MethodInterceptor {
    private Object obj ;

    public lawyerInteceptor(Object object) {
        this.obj = object;
    }

    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        if(method.getName().equals("speak")){
            System.out.println("应用法律条文");
            method.invoke(obj,args);
            System.out.println("道德谴责");
        }
        return null;
    }
}
class Demo{
    public static void main(String[] args) {
        /**
         * 1.静态代理，
         * 优点:简单容易实现
         * 缺点：在程序运行前，代理类的.class文件就已经存在了，委托类对应一个代理类，当有多个委托类就要写多个代理类
         */
        Speaker speaker = new ZhangsanLawyer();
        speaker.speak();
        /**
         * 2.jdk动态代理
         * 需要被代理的对象必须实现speak委托类的接口，没有实现的共同接口的类将无法被代理
         */
        LawyerProxy lawyerProxy = new LawyerProxy(new Zhangsan());
        Speaker speaker1 = (Speaker) Proxy.newProxyInstance(Demo.class.getClassLoader(),new Class[]{Speaker.class},lawyerProxy);
        speaker1.speak();
        /**
         * 3.CGLib动态代理：作为jdk代理的补充,没有实现的共同接口的类也可以被代理
         */
        lawyerInteceptor lawyerInteceptor = new lawyerInteceptor((new Lisi()));
        Lisi lisi = (Lisi) Enhancer.create(Lisi.class,lawyerInteceptor);
        lisi.speak();
    }
}
```
