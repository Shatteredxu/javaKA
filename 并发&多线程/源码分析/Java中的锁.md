# Java中的锁

#### 偏向锁/轻量级锁/重量级锁

这三种锁特指 synchronized 锁的状态，通过在对象头中的 mark word 来表明锁的状态。JDK1.5以后synchronized 从之前的重量级锁优化为偏向锁/轻量级锁/重量级锁。

***偏向锁：***当资源不存在其他线程竞争时，就不需要加锁，只需要打个标记就可以，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。

***轻量级：***不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。

***重量级锁：***重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁

#### 可重入锁/非可重入锁；

可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。同理，不可重入锁指的是虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。

使用场景：

#### 共享锁/独占锁；

共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同时被一个线程获得。我们的读写锁，就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。



#### 公平锁/非公平锁

公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。

<img src="assets/CgpOIF4Jsh6AbVZ-AAB_Y_MH7f4077.png" alt="img" style="zoom:67%;" />

##### 公平锁和非公平锁源码区别（以ReentrantLock 为例）

```java
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        //公平锁在这里会判断队列是否还有任务，没有任务的时候才允许线程去获取
        if (!hasQueuedPredecessors() && //这里判断了 hasQueuedPredecessors()
                compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) {
            throw new Error("Maximum lock count exceeded");
        }
        setState(nextc);
        return true;
    }
    return false;
}
```

当有线程执行 tryLock() 方法的时候，一旦有线程释放了锁，那么这个正在 tryLock 的线程就能获取到锁，即使设置的是公平锁模式，即使在它之前已经有其他正在等待队列中等待的线程，简单地说就是 tryLock 可以插队（**其源码调用的时非公平锁**）。



#### 悲观锁/乐观锁；

**悲观锁**的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。而**乐观锁**恰恰相反，不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。

也就是说乐观锁在不加锁的情况下使用CAS去修改值，如果CAS失败则代表有其他线程正在使用，则放弃此次修改，重新CAS.

悲观锁：synchronized 关键字和 Lock 接口

乐观锁：原子类：AtomicInteger 在更新数据时，就使用了乐观锁的思想，多个线程可以同时操作同一个原子变量。

##### 使用场景：

悲观锁适合用于并发写入多、临界区代码复杂、竞争激烈等场景，这种场景下悲观锁可以避免大量的无用的反复尝试等消耗。

乐观锁适用于大部分是读取，少部分是修改的场景，也适合虽然读写都很多，但是并发并不激烈的场景。在这些场景下，乐观锁不加锁的特点能让性能大幅提高。

#### 自旋锁/非自旋锁；

非自旋锁和自旋锁最大的区别，就是如果它遇到**拿不到锁的情况，它会把线程阻塞，直到被唤醒**。而自旋锁会不停地通过CAS去尝试。

##### ***优点：***

阻塞和唤醒线程都是需要高昂的开销的，如果同步代码块中的内容不复杂，那么可能转换线程带来的开销比实际业务代码执行的开销还要大。

所以自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，**节省了线程状态切换带来的开销**。JDK1.5以上的原子类基本都是用自旋锁CAS更新。

比如我们看一个 AtomicLong 的实现，里面有一个 getAndIncrement 方法，源码如下：

```java
public final long getAndIncrement() {
    return unsafe.getAndAddLong(this, valueOffset, 1L);
}
public final long getAndAddLong (Object var1,long var2, long var4){
    long var6;
    do {//通过dowhile不断地去尝试获取变量
        var6 = this.getLongVolatile(var1, var2);
    } while (!this.compareAndSwapLong(var1, var2, var6, var6 + var4));
    return var6;
}
```

##### **缺点：**

如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。

##### 使用场景

自旋锁适用于**并发度不是特别高的场景**，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。

可是如果临界区很大，**线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁**，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。

#### 可中断锁/不可中断锁

synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 **lockInterruptibly 方法在获取锁**的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。

#### 读写锁

#### 读锁插队策略

```java
//true为公平锁，false为非公平锁
ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(true);
```

##### 非公平锁的实现

```java
final boolean writerShouldBlock() {
    return false; // 写锁不能插队
}
final boolean readerShouldBlock() {
// 等待队列的头结点是尝试获取写锁的线程，那么读锁依然是不能插队的，目的是避免“饥饿”。
    return apparentlyFirstQueuedIsExclusive();
}
```

##### 读写锁会降级

当我们只需要读取数据不需要写数据的时候，就会自动降级为读锁。但是读写锁**不支持升级**

#### 锁优化方法

相比于 JDK 1.5，在 JDK 1.6 中 HotSopt 虚拟机对 synchronized 内置锁的性能进行了很多优化，包括自适应的自旋、锁消除、锁粗化、偏向锁、轻量级锁等。

##### 自旋锁优化

在 JDK 1.6 中引入了自适应的自旋锁来解决长时间自旋的问题。自适应意味着自旋的时间不再固定，而是会根据最近自旋尝试的成功率、失败率，以及当前锁的拥有者的状态等多种因素来共同决定。自旋的持续时间是变化的，

##### 锁消除

在大多数情况下，它只会在一个线程内被使用，如果编译器能确定这个 StringBuffer 对象**只会在一个线程内被使用**，就代表肯定是**线程安全**的，那么我们的编译器便会做出优化，把**对应的 synchronized 给消除**，省去加锁和解锁的操作，以便增加整体的效率。

##### 锁粗化

如果代码中有接连获取锁和释放锁，那么编译器科能将同步区域扩大，也就是只在最开始加一次锁，并且在最后直接解锁，那么就可以把中间这些无意义的解锁和加锁的过程消除，相当于是把几个 synchronized 块合并为一个较大的同步块。

<u>好处就是省去了加锁释放锁的开销，坏处就是锁可能一直得不到释放，例如循环的场景，锁一直不能释放导致其他线程饥饿</u>

##### 锁升级

从无锁到偏向锁，再到轻量级锁，最后到重量级锁。结合前面我们讲过的知识，偏向锁性能最好，避免了 CAS 操作。而轻量级锁利用自旋和 CAS 避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁则会把获取不到锁的线程阻塞，性能最差。