2. 通信和序列化
---------------

> 本节主要解决如何实现高性能的客户端和服务器端通信，以及如何将结构化的数据序列化成字节流，用于网络传输或者存储到文件中。

### 2.1 高性能的序列化和反序列化

##### 为什么要序列化

1. 减小内存空间和网络传输的带宽

2. 分布式的可扩展性

3. 通用性，接口可共用。

##### dubbo序列化方式

Dubbo序列化支持java、compactedjava、nativejava、fastjson、dubbo、fst、hessian2、kryo，其中默认hessian2。其中java、compactedjava、nativejava属于原生java的序列化。

***dubbo序列化：***阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它。

***hessian2序列化：***hessian是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的，它是dubbo RPC默认启用的序列化方式。
		***json序列化：***目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。
		***java序列化：*** 主要是采用JDK自带的Java序列化实现，性能很不理想。

##### 为什么 RPC 框架不采用性能更好的专用的序列化实现

RPC 框架，它需要序列化的数据是，用户调用远程方法的参数，这些参数可能是各种数据类型，所以必须使用通用的序列化实现，确保各种类型的数据都能被正确的序列化和反序列化。我们这里还是采用专用的序列化实现

##### Protobuf序列化





### 2.2 网络通信

在实现异步网络传输的时候，一定要配套实现一个**背压的机制**，避免客户端请求速度过快，导致大量的请求失败。

