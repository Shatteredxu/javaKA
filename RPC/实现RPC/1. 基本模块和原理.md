RPC基本介绍
-----------

RPC(Remote Procedure Call，远程过程调用)是一种计算机通信协议，允许调用不同进程空间的程序。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。

#####  RPC 框架需要解决什么问题

1. 两个机器通信使用什么的协议？
2. 报文的编码格式用什么？
3. 处理错误情况：连接超时，异步同步请求
4. 注册中心通常还需要实现服务**动态添加、删除，使用心跳**确保服务处于可用状态等功能
5. 实现一套消息编解码、连接池、收发线程、超时处理

主要由注册中心，客户端，服务器端组成

***注册中心：***SOFARegistry, Zookeeper, 本地文件, Consul, Nacos

***通信协议：***Bolt协议，Http 协议， 


-

##### RPC 框架需要实现的功能

Check Style 规范代码结构



* 通信：使用Netty作为通信框架。
* 序列化:hession2、kyro、protostuff
* **服务发布与订阅：**服务端使用Zookeeper注册服务地址，客户端从Zookeeper获取可用的服务地址。
* 负载均衡/软负载：提供丰富的负载均衡策略，包括：轮询、随机、LRU、LFU、一致性HASH等；
* Spring：使用Spring配置服务，加载Bean，扫描注解。
* **动态代理：**客户端使用代理模式透明化服务调用。
* **消息编解码：**使用Protostuff序列化和反序列化消息。
* 异步调用，支持Future机制，回调callback（SYNC、ONEWAY、FUTURE、CALLBACK）
* **动态代理** ：  RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，使用动态代理可以屏蔽远程方法调用的细节比如网络传输。也就是说当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法呢？

* 客户端使用TCP长连接（在多次调用共享连接）
* TCP心跳连接检测
* 服务端异步多线程处理RPC请求
* 支持不同的load balance策略

* 8、服务治理：提供服务治理中心，可在线管理注册的服务信息，如服务锁定、禁用等；
* 9、服务监控：可在线监控服务调用统计信息以及服务健康状况等（计划中）；

* 容错：服务提供方集群注册时，某个服务节点不可用时将会自动摘除，同时消费方将会移除失效节点将流量分发到其余节点，提高系统容错能力。

* （TODO）解决1+1问题：传统分布式通讯一般通过nginx或f5做集群服务的流量负载均衡，每次请求在到达目标服务机器之前都需要经过负载均衡机器，即1+1，这将会把流量放大一倍。而XXL-RPC将会从消费方直达服务提供方，每次请求直达目标机器，从而可以避免上述问题；

> * **使用 Netty（基于 NIO）替代 BIO 实现网络传输；**
>
> *  **使用开源的序列化机制 Kyro（也可以用其它的）替代 JDK 自带的序列化机制；**
>
> *  **使用 Zookeeper 管理相关服务地址信息**
>
> *  Netty 重用 Channel 避免重复连接服务端
>
> *  使用 `CompletableFuture` 包装接受客户端返回结果（之前的实现是通过 `AttributeMap` 绑定到 Channel 上实现的） 详见：[使用 CompletableFuture 优化接受服务提供端返回结果](https://github.com/Snailclimb/guide-rpc-framework/blob/master/docs/使用CompletableFuture优化接受服务提供端返回结果.md)
>
> *  **增加 Netty 心跳机制** : 保证客户端和服务端的连接不被断掉，避免重连。
>
> *  **客户端调用远程服务的时候进行负载均衡** ：调用服务的时候，从很多服务地址中根据相应的负载均衡算法选取一个服务地址。ps：目前实现了随机负载均衡算法与一致性哈希算法。
>
> *  **处理一个接口有多个类实现的情况** ：对服务分组，发布服务的时候增加一个 group 参数即可。
>
> *  **集成 Spring 通过注解注册服务**
>
> *  **集成 Spring 通过注解进行服务消费** 。参考： [PR#10](https://github.com/Snailclimb/guide-rpc-framework/pull/10)
>
> *  **增加服务版本号** ：建议使用两位数字版本，如：1.0，通常在接口不兼容时版本号才需要升级。为什么要增加服务版本号？为后续不兼容升级提供可能，比如服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。
>
> *  **对 SPI 机制的运用**
>
> *  **增加可配置比如序列化方式、注册中心的实现方式,避免硬编码** ：通过 API 配置，后续集成 Spring 的话建议使用配置文件的方式进行配置
>
> *  
>
>   客户端与服务端通信协议（数据包结构）重新设计
>
>   ，可以将原有的RpcRequest和RpcReuqest对象作为消息体，然后增加如下字段（可以参考：《Netty 入门实战小册》和 Dubbo 框架对这块的设计）：
>
>   * **魔数** ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。
>   * **序列化器编号** ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化方式。
>   * **消息体长度** ： 运行时计算出来。
>   * ......
>
> *  **编写测试为重构代码提供信心**
>
> *  **服务监控中心（类似dubbo admin）**
>
> *  **设置 gzip 压缩**







> https://www.sofastack.tech/projects/sofa-rpc/roadmap/
>
> #### v5.5.0
>
> * JSON 序列化支持
> * H2的TLS安全支持
> * 弹性连接池
> * hystrix集成
> * Consul注册中心支持
>
> #### v5.6.0
>
> * grpc 通讯层支持
> * etcd注册中心支持
> * SofaMesh支持
> * BOLT 版本协商与 CRC 校验
>
> #### v5.7.0
>
> * Telnet 内置指令支持
> * SpringBoot 2.0 支持
> * Mock功能支持
> * 加密功能支持
>
> #### v5.8.0
>
> * 授权支持
> * SofaRegistry 支持
> * Reactive 支持
