SQL语句调优
-----------

##### 索引

1.   建立索引，根据索引最左前缀原则，建立适当的联合索引，索引合理进行选择
2.   避免索引失效：函数计算，预编译查询，调整where字段上的顺序，**类型转换**

>   索引失效情况：(1) Like的参数以通配符开头时
>
>   ​							(2) where条件不符合最左前缀原则时
>
>   ​							(3) 使用！= 或 <> 操作符时
>
>   ​							(4) 避免索引列参与计算
>
>   ​							(5) 避免对字段进行null值判断
>
>   ​							(6) 避免使用or来连接条件

3.   统一字符集：避免出现字符不同而转换导致索引失效

##### 锁

避免死锁

##### SQL语句使用不当

1.避免使用select *

2.group by检查

3.order by检查

4.limit检查

### 优化 SQL 语句的步骤

##### 1.通过EXPLAIN分析SQL执行计划

[参考](https://zhuanlan.zhihu.com/p/51771446)

explain后边跟着SQL语句，编写完一条SQL语句，往往想知道这条SQL语句执行是否高效。或者说，我们建立好的索引在这条SQL语句中是否使用到了，就可以使用explain命令来分析一下

通过explain命令我们可以知道以下信息：**表的读取顺序**，**数据读取操作的类型**，**哪些索引可以使用**，哪些索引实际使用了，表之间的引用，**每张表有多少行被优化器查询等信息**。

explain命令输出的结果有10列：id、select_type、table、**type**、possible_keys、key、key_len、ref、rows、Extra

select_type：

>  **SIMPLLE**：简单查询，该查询不包含 UNION 或子查询
>
>  **PRIMARY**：如果查询包含UNION 或子查询，则**最外层的查询**被标识为PRIMARY
>
>  **SUBQUERY**：子查询中的第一个select语句(该子查询不在from子句中)
>
>  **DERIVED**：包含在from子句中子查询(也称为派生表)

table：表示了查询了那个表

type：

> 该列称为**关联类型或者访问类型**，它指明了MySQL决定如何查找表中符合条件的行，同时**是我们判断查询是否高效的重要依据**。
>
> * ALL：**全表扫描**，这个类型是性能最差的查询之一。通常来说，我们的查询不应该出现 ALL 类型
> * index：**全索引扫描**，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型是扫描全部的索引，主要优点是避免了排序，但是开销仍然非常大。如果在 Extra 列看到 Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要少很多。
> * range：**范围扫描**，就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行。这个类型通常出现在 `=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN、IN()` 的操作中，key 列显示使用了哪个索引，当 type 为该值时，则输出的 ref 列为 NULL，并且 key_len 列是此次查询中使用到的索引最长的那个。
> * ref：一种索引访问，也称**索引查找**，它返回所有匹配某个单个值的行。此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了最左前缀规则索引的查询。
> * eq_ref：使用这种索引查找，**最多只返回一条符合条件的记录**。在使用唯一性索引或主键查找时会出现该值，非常高效。
> * const、system：该表至多有一个匹配行，在查询开始时读取，或者该表是系统表，只有一行匹配。其中 const 用于在和 primary key 或 unique 索引中有固定值比较的情形。
> * NULL：在执行阶段不需要访问表。

extra：

> * **Using index**：使用覆盖索引，表示查询索引就可查到所需数据，不用扫描表数据文件，往往说明性能不错。
> * Using Where：在存储引擎检索行后再进行过滤，使用了where从句来限制哪些行将与下一张表匹配或者是返回给用户。
> * Using temporary：在查询结果排序时会使用一个临时表，一般出现于排序、分组和多表 join 的情况，查询效率不高，建议优化。
> * Using filesort：对结果使用一个外部索引排序，而不是按索引次序从表里读取行，一般有出现该值，都建议优化去掉，因为这样的查询 CPU 资源消耗大。

2.通过 Show Profile 分析 SQL 执行性能

>   ```text
>    //show profiles 展示最近执行的多个SQL的执行耗时情况，具体能收集多少个SQL，由参数 profiling_history_size决定
>    //show profile 展示一个SQL语句的执行耗时细节，如果不加 for query {n} 子句，默认展示最新的一次SQL的执行情况，加了for query {n}，表示展示第n个 SQL的执行情况
>   type 参数：
>   | ALL：显示所有开销信息
>   | BLOCK IO：阻塞的输入输出次数
>   | CONTEXT SWITCHES：上下文切换相关开销信息
>   | CPU：显示 CPU 的相关开销信息 
>   | IPC：接收和发送消息的相关开销信息
>   | MEMORY ：显示内存相关的开销，目前无用
>   | PAGE FAULTS ：显示页面错误相关开销信息
>   | SOURCE ：列出相应操作对应的函数名及其在源码中的调用位置 (行数) 
>   | SWAPS：显示 swap 交换次数的相关开销信息
>   ```

##### 优化 SELECT COUNT(*)
