







#### **6.** ***\*索引的作用？和它的优点缺点是什么\****

索引就一种特殊的查询表，数据库的搜索可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小，唯一、不为空、经常被查询的字段适合建索引

#### **7.** 什么是事务？什么是锁？



#### **8.** 什么叫视图？游标是什么？视图的优缺点

是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。 游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。***\*可以对结果集当前行做修改\****。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

1）视图可以有选择性的选取数据库里的一部分。 2）对数据库中的一些字段修改 3 ）屏蔽数据库的复杂性。 4）简化用户权限的管理。 缺点： 性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据

#### 列举几种表连接方式,有什么区别？

内连接（等值，非等值）、自连接、外连接（左、右、全）、交叉连接 内连接：只有两个元素表相匹配的才能在结果集中显示。 外连接： 左外连接:左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 全外连接：连接的表中不匹配的数据全部会显示出来。 交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。

#### **9.** ***\*在数据库中查询语句速度很慢，如何优化？\****

1.建索引 

2.减少表之间的关联 

3.优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据 量大的表排在前面 

4.简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 5

.尽量用PreparedStatement来查询，不要用Statement

#### 10.关系型数据库和非关系型数据库区别

关系型优点

1、容易理解

2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；

3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；

4、支持SQL，可用于复杂的查询。

5.支持事务

缺点

1、为了维护一致性所付出的巨大代价就是其读写性能比较差；

2、固定的表结构；

3、不支持高并发读写需求；

4、不支持海量数据的高效率读写

非关系型

处理高并发、大批量数据的能力强

支持分布式集群，负载均衡，性能高

内存级数据库，查询速度快

存储格式多，支持key-value形式、文档形式、图片形式

没有多表连接查询机制的限制，扩展性高

#### 11有哪些锁,select时怎么加排它锁

乐观锁 悲观锁 排它锁 行锁 表锁

#### **12.** ***\*最左匹配原则\****

https://www.cnblogs.com/lanqi/p/10282279.html

#### **13.** ***\*什么时候应该加索引\****

第一，查询中很少使用不应该创建索引。

第二，对于那些只有很少数据值的列也不应该增加索引。

第三，对于那些定义为text, image和[bit数据类型](https://baike.baidu.com/item/bit数据类型)的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少,不利于使用索引。

第四，当修改性能远远大于检索性能时，不应该创建索引。

#### ***\*14.数据库三大范式\****

https://www.zhihu.com/question/24696366

一范式：属性不可再分

二范式：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖

三范式：传递函数依赖

#### ***\*15.\*******\*drop、delete与truncate\****

DDL：(Data Definition Language 数据定义语言)用于操作对象和对象的属性，这种对象包括数据库本身，以及数据库对象，像：表、视图等等，以表举例：Create创建数据表，Alter可以更改该表的字段，Drop可以删除这个表，从这里我们可以看到，DDL所站的高度，他不会对具体的数据进行操作。

DML(Data Manipulation Language 数据操控语言)用于操作数据库对象中包含的数据，也就是说操作的单位是记录。

DCL(Data Control Language 数据控制语句)的操作是数据库对象的权限，这些操作的确定使数据更加的安全。

Drop：删除表和数据

truncate ：删除表内容，不能回滚，不带where

delete ：删除数据，待where

DELETE是一条一条记录的删除，而Truncate是将整个表删除，保留表结构，这样比DELETE快

#### **16.** ***\*数据库的乐观锁和悲观锁是什么？\****

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 

**·** ***\*在查询完数据的时候就把事务锁起来，直到提交事务\****

· 实现方式：使用数据库中的锁机制

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 

***\*在修改数据的时候把事务锁起来，通过version的方式来进行锁定\****

实现方式：使用version版本或者时间戳

#### **17.** ***\*超键、候选键、主键、外键\****

***\*超键包含候选键和主键\****

#### **18.** ***\*为什么不都用Hash索引而使用B+树索引？\****

Hash索引仅仅能满足"=","IN"和""查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；

Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；

Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；

Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；

Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。

#### **19.** ***\*数据库管理系统的功能\****

数据定义功能，数据组织存储功能，数据操纵功能，数据库建立和维护功能

#### **20.** ***\*数据库系统\****

包括数据库，DBMS，DBA，应用程序

#### **21.** ***\*数据模型\****

主要是对现实世界数据特征的抽象，用来描述数据和组织数据，主要分为第一类是概念模型，第二类是逻辑模型和物理模型。

第一类概念模型，也称信息模型，它是按用户的观点来对数据和

信息建模，主要用于数据库设计

第二类中的逻辑模型主要包括层次模型(hierarchical model)、网状模型(network model)、

关系模型(relational model)、面向对象数据模型(object oriented data model)和对象关系数据

模型(object relational data model)、半结构化数据模型(semistructured data model)等。它是

按计算机系统的观点对数据建模，主要用于数据库管理系统的实现

#### **22.** ***\*常见的数据模型\****

层次模型，网状，关系，面向对象

#### ***\*23.文件系统和数据库系统的区别\****

#### ***\*24.行级触发器和语句级触发器\****

语句及触发器：触发器只会在相应的语句执行或者是执行之后执行一次。

行级触发器：也就是说相应的语句有影响到几行记录，就执行几次触发器。

#### **25.** ***\*mysql锁\****

#### **26.** ***\*范式\****

 

https://zhuanlan.zhihu.com/p/20028672

#### **27.** ***\*ER图\****

实体关系图 (Entity-Relationship，E-R)，有三个组成部分：实体、属性、联系。用来进行关系型

数据库系统的概念设计。

#### **28.** ***\*使用RAID增加硬盘的性能\****

| 等级   | 特点             | 是否冗余 | 盘数 | 读   | 写   |
| ------ | ---------------- | -------- | ---- | ---- | ---- |
| RAID0  | 便宜，快速，危险 | 否       | N    | Kuai | 快   |
| RAID1  | 高速读简单安全   | 有       |      | 快   | 慢   |
| RAID5  | 安全，成本折中   | 有       | N+1  | 块   | 最慢 |
| RAID10 | Gui，高速，安全  | 有       | 2N   | 快   | 快   |

**29.** [***\*MySQL提升课程 全面讲解MySQL架构设计\****](https://coding.imooc.com/class/49.html)https://segmentfault.com/a/1190000013672421

**30.** ***\*INNODB存储引擎的特性\****

***\*事务性存储引擎，支持事务ACID，redo log 和undo log ,行级锁，行级锁由存储引擎实现，\****

###  分库分表

https://segmentfault.com/a/1190000023914691

遇到的问题：用户请求量太大（负载均衡到多个服务器上，）单库太大（切分成更多更小的库）单表太大（索引膨胀，查询超时 解决方法：切分成多个数据集更小的表）

又分为：**垂直切分**和**水平切分**

##### **垂直切分：**

**垂直分表：**因为**表多而数据多**，使用垂直切分，根据业务切分成不同的库。也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。

**垂直分库：**如果放在一个数据库服务器上， 随着用户量增大，这会让单个数据库的处理能力成为瓶颈，还有单个服务器的磁盘空间，内存，tps等非常吃紧。 所以我们要拆分到多个服务器上，放在不同的服务器上缓解压力

##### **水平切分**

水平分表：针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。

水平分库分表：将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。

range进行分库分表：会造成热点数据，热点数据频繁访问，其他的很少访问。

hash方法：范围查询等业务需求，需要联合多个表和库；而且后期扩容需要重新进行hash，（**<u>一致性Hash算法</u>**可以避免）

**缺点：**跨分片的事务一致性难以保证，跨库的join关联查询性能较差，数据多次扩展难度和维护量极大

##### 分库分表后面临的问题

**事务支持：**变为分布式事务

数据一致性保证

**跨节点关联查询 join 问题**

**跨节点分页、排序、函数问题**

**全局主键避重问题**

##### 大厂中间件

- sharding-jdbc（当当）
- TSharding（蘑菇街）
- Atlas（奇虎360）
- Cobar（阿里巴巴）
- MyCAT（基于Cobar）
- Oceanus（58同城）
- Vitess（谷歌）

##### MyISAM和InnoDB索引的区别？

***1 存储结构（主索引／辅助索引）***

​     InnoDB的数据文件本身就是主索引文件。而MyISAM的主索引和数据是分开的。

​     InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。

​     innoDB是聚簇索引，数据挂在主键索引之下。

***2 锁***

​		MyISAM使用的是表锁  InnoDB使用行锁

***3 事务***

​		MyISAM没有事务支持和MVCC

​		InnoDB支持事务和MVCC

***4 主键***

​		MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址

​		InnoDB如果没有设定主键或非空唯一索引，就会自动生成一个6字节的主键，数据是主索引的一部分，附加索引保存的是主索引的值

***5 外键***

​		MyISAM不支持，InnoDB支持

###  SQL语句

建表语句：

```sql
create table if not exists user_info_vip (
    id int(11) primary key auto_increment comment '自增ID',
    uid int(11) unique not null comment '用户ID',
    nick_name varchar(64) comment '昵称',
    achievement int(11) default 0 comment '成就值',
    level int(11) comment '用户等级',
    job varchar(32) comment '职业方向',
    register_time datetime default current_timestamp comment '注册时间'
```

##### MySQL 中 int (10) 和 int (11) 到底有什么区别？

括号中的值为显示宽度，显示宽度整数类型的取值范围是无关的。显示宽度只是指明 mysql 最大可能显示的数字个数，数值的位数小于指定的宽度时就由空格填充，如果插入了大于显示宽度的值，**只要该值不超过该类型整数的取值范围**，数值依然可以插入，而且能够显示出来。

所以 int (10) 和 int (11) 没有任何区别，就是显示宽度不同

##### 创建索引

```sql
-- 唯一索引
ALTER TABLE examination_info ADD UNIQUE INDEX uniq_idx_exam_id(exam_id);
 
-- 全文索引
ALTER TABLE examination_info ADD FULLTEXT INDEX full_idx_tag(tag);
  
-- 普通索引
ALTER TABLE examination_info ADD INDEX idx_duration(duration);
```

>   加行锁的情况：1. 创建索引，select 2.有事务3.在select 语句后面 加 上   FOR UPDATE；

### mysql如何显式的上行锁

mysql隐式上行锁：在事务的执行过程中.会进行锁定,锁只有在commit或rollback的时候,才会同时被释放

显式的上行锁：select ... lock in share mode（共享锁） ; select ... for update（排它锁）,where条件里面的必须是主键,否则会锁整张表

### mysql什么时候使用表锁

