索引
----

[TOC]



### 索引概述

InnoDB存储引擎支持以下几种常见的索引：

❑B+树索引

❑全文索引

❑哈希索引

### B+树

[参考](https://blog.csdn.net/weixin_42228338/article/details/97684517)

##### B树基本知识

**b树**节点分布情况：除根节点外的所有非叶节点**至少含有（M/2（向上取整）-1）个关键字**，每个节点最多有**M-1个关键字**，并且以升序排列。所以M阶B树的除根节点外的所有非叶节点的关键字取值区间为**[M/2-1(向上取整),M-1]**。

![img](assets/B数插入节点.gif)

##### B+树基本知识

**在B+树中**，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接

有n棵子树的**非叶子结点中含有n个关键字**（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（**b树是每个关键字都保存数据**）。
所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接（叶子节点组成一个链表）。
所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
通常在b+树上有**两个头指针，一个指向根结点，一个指向关键字最小的叶子结点**。
同一个数字会在不同节点中重复出现，**根节点的最大元素就是b+树的最大元素**。

##### B树与B+树的区别

1. B树每个节点都存储数据,B+树只有叶子节点存储数据
2. B树中每个节点（非根节点）关键字个数的范围为[m/2(向上取整)-1,m-1](根节点为[1,m-1])，并且具有n个关键字的节点包含（n+1）棵子树。B+树中每个节点（非根节点）关键字个数的范围为[m/2(向上取整),m](根节点为[1,m])，具有n个关键字的节点包含（n）棵子树。
3. B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。

##### B+树的优点

1. 所有的叶子结点使用链表相连，**便于区间查找和遍历**。B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。
2. b+树的中间节点不保存数据，能容纳更多节点元素

### B+树索引

数据库中的B+树索引可以分为聚集索引（clustered inex）和辅助索引（secondary index），但是不管是聚集还是辅助的索引，其内部都是B+树的，即高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的是，**叶子节点存放的是否是一整行的信息。**

##### 聚簇索引（主键索引）

聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，每张表只能拥有一个聚集索引，在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据，而辅助索引存放的仅仅是键值及指向数据页的偏移量，而不是一个完整的行记录

聚集索引的存储并不是物理上连续的，而是逻辑上连续的。这其中有两点：一是前面说过的页通过双向链表链接，页按照主键的顺序排序；另一点是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。

聚集索引的另一个好处是，它对于主键的排序查找和范围查找速度非常快。叶子节点的数据就是用户所要查询的数据。如用户需要查询一张注册用户的表，查询最后注册的10位用户，由于B+树索引是双向链表的，用户可以快速找到最后一个数据页，并取出10条记录。对于B+树的**范围查询**也很快

##### 辅助索引（二级索引）

对于辅助索引（Secondary Index，也称非聚集索引），叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark）。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据

##### 数据块B+索引的分裂

由于在插入时，有些节点分裂后就不会有值插入，但是宁外一边就会一直有数据，导致一直分裂，所以：

InnoDB存储引擎可以决定是向左还是向右进行分裂，同时决定将分裂点记录为哪一个

##### B+树索引的管理

索引的创建和删除

Fast Index Creation

Online Schema Change

### Cardinality值

##### 什么是Cardinality

并不是在所有的查询条件中出现的列都需要添加索引。对于什么时候添加B+树索引，一般的经验是，在访问表中很少一部分时使用B+树索引才有意义。对于性别字段、地区字段、类型字段，它们可取值的范围很小，称为低选择性。所以在构造索引时，我们应尽可能选择高选择性的字段，这样它的不重复值更多，更有区分度。

Cardinality值表示索引中不重复记录数量的预估值，Cardinality/n_rows_in_table应尽可能地接近1，代表这个表不重复的值就越多。

##### InnoDB存储引擎的Cardinality统计

数据库对于Cardinality的统计都是通过采样（Sample）的方法来完成的,

在InnoDB存储引擎中，Cardinality统计信息的更新发生在两个操作中：INSERT和UPDATE。根据前面的叙述，不可能在每次发生INSERT和UPDATE时就去更新Cardinality信息，这样会增加数据库系统的负荷，同时对于大表的统计，时间上也不允许数据库这样去操作。因此，InnoDB存储引擎内部对更新Cardinality信息的策略为：

❑表中1/16的数据已发生过变化。

❑stat_modified_counter＞2 000 000 000。(InnoDB存储引擎内部有一个<u>计数器stat_modified_counter</u>，用来表示发生变化的次数，当stat_modified_counter大于2 000 000 000时，则同样需要更新Cardinality信息)



<u>**InnoDB存储引擎内部是怎样来进行Cardinality信息的统计和更新操作的呢？**</u>

同样是通过采样的方法。默认InnoDB存储引擎对**8个叶子节点**（Leaf　Page）进行采用。采样的过程如下：

❑取得B+树索引中叶子节点的数量，记为A。

❑随机取得B+树索引中的8个叶子节点。统计每个页不同记录的个数，即为P1，P2，…，P8。

❑根据采样信息给出Cardinality的预估值：Cardinality=（P1+P2+…+P8）*A/8。

通过上述的说明可以发现，在InnoDB存储引擎中，Cardinality值是通过对8个叶子节点预估而得的，不是一个实际精确的值。再者，每次对Cardinality值的统计，都是通过随机取8个叶子节点得到的，所以在数据量不小的情况下，每次得到的Cardinality值可能是不同的，因为是每次随机抽样得来的。

### B+树索引的使用

**在OLTP应用中，**查询操作只从数据库中取得一小部分数据，在这种情况下，B+树索引建立后，对该索引的使用应该只是通过该索引取得表中少部分的数据。这时建立B+树索引才是有意义的，否则即使建立了，优化器也可能选择不使用索引。

对于OLAP应用，要涉及多张表之间的联接操作，因此索引的添加依然是有意义的。但是，如果联接操作使用的是Hash Join，那么索引可能又变得不是非常重要了

##### 联合索引

联合索引是指对表上的多个列进行索引，联合索引也是一棵B+树，不同的是联合索引的键值的数量不是1，而是大于等于2。

但是我们在使用联合索引的时候，并不能跳过第一个索引段，去使用第二个，而是在第一个基础上去查找使用第二个索引段

##### 覆盖索引

覆盖索引即**从辅助索引中就可以得到查询的记录**，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此**可以减少大量的IO操作**（减少回表操作）。

如果需要根据身份证号码去查询一个人的名字，这个时候如果建立身份证号码的索引们就会存在回表操作，但是如果建立（身份证号码，姓名）的索引，就可以减少回表操作

##### 优化器选择不使用索引的情况

不使索引的情况：

##### 索引提示

1. MySQL数据库的优化器错误地选择了某个索引，导致SQL语句运行的很慢
2. 某SQL语句可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身

##### Multi-Range Read优化

Multi-Range Read优化的目的就是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，

##### Index Condition Pushdown（ICP）优化

在支持Index Condition Pushdown后，MySQL数据库会在取出索引的同时，判断是否可以进行WHERE条件的过滤，也就是将WHERE的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取（fetch），从而提高数据库的整体性能

### 哈希算法

##### 自适应哈希索引

再写

### 全文检索

##### 倒排索引

### 本章面试题

###### 1.mysql索引优点

###### 2.索引最左前缀生效原则

###### 3.创建索引原则

> 1. 在**经常需要搜索的列上**，可以加快搜索的速度
> 2. **在作为主键的列上**，强制该列的唯一性和组织表中数据的排列结构
> 3. **在经常用在连接（JOIN）的列上**，这些列主要是一外键，可以加快连接的速度
> 4. 在经常需要根据范围（**<，<=，=，>，>=，BETWEEN，IN**）进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
> 5. 在经常需要排序（order by）的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
> 6. 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
> 7. 只有很少数据值或者重复值多的列也**不应该增加索引**
> 8. 对于那些定义为text, image和bit数据类型的列**不应该增加索引**。

###### 聚簇索引和非聚簇索引的区别

###### explain怎么使用

[参考](https://zhuanlan.zhihu.com/p/51771446)

explain后边跟着SQL语句，编写完一条SQL语句，往往想知道这条SQL语句执行是否高效。或者说，我们建立好的索引在这条SQL语句中是否使用到了，就可以使用explain命令来分析一下

通过explain命令我们可以知道以下信息：**表的读取顺序**，**数据读取操作的类型**，**哪些索引可以使用**，哪些索引实际使用了，表之间的引用，**每张表有多少行被优化器查询等信息**。

explain命令输出的结果有10列：id、select_type、table、**type**、possible_keys、key、key_len、ref、rows、Extra

select_type：

>  **SIMPLLE**：简单查询，该查询不包含 UNION 或子查询
>
> **PRIMARY**：如果查询包含UNION 或子查询，则**最外层的查询**被标识为PRIMARY
>
> **SUBQUERY**：子查询中的第一个select语句(该子查询不在from子句中)
>
> **DERIVED**：包含在from子句中子查询(也称为派生表)

table：表示了查询了那个表

type：

> 该列称为**关联类型或者访问类型**，它指明了MySQL决定如何查找表中符合条件的行，同时**是我们判断查询是否高效的重要依据**。
>
> * ALL：**全表扫描**，这个类型是性能最差的查询之一。通常来说，我们的查询不应该出现 ALL 类型
> * index：**全索引扫描**，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型是扫描全部的索引，主要优点是避免了排序，但是开销仍然非常大。如果在 Extra 列看到 Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要少很多。
> * range：**范围扫描**，就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行。这个类型通常出现在 `=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN、IN()` 的操作中，key 列显示使用了哪个索引，当 type 为该值时，则输出的 ref 列为 NULL，并且 key_len 列是此次查询中使用到的索引最长的那个。
> * ref：一种索引访问，也称**索引查找**，它返回所有匹配某个单个值的行。此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了最左前缀规则索引的查询。
> * eq_ref：使用这种索引查找，**最多只返回一条符合条件的记录**。在使用唯一性索引或主键查找时会出现该值，非常高效。
> * const、system：该表至多有一个匹配行，在查询开始时读取，或者该表是系统表，只有一行匹配。其中 const 用于在和 primary key 或 unique 索引中有固定值比较的情形。
> * NULL：在执行阶段不需要访问表。

extra：

> * **Using index**：使用覆盖索引，表示查询索引就可查到所需数据，不用扫描表数据文件，往往说明性能不错。
> * Using Where：在存储引擎检索行后再进行过滤，使用了where从句来限制哪些行将与下一张表匹配或者是返回给用户。
> * Using temporary：在查询结果排序时会使用一个临时表，一般出现于排序、分组和多表 join 的情况，查询效率不高，建议优化。
> * Using filesort：对结果使用一个外部索引排序，而不是按索引次序从表里读取行，一般有出现该值，都建议优化去掉，因为这样的查询 CPU 资源消耗大。

###### mysql的profile命令

###### 什么时候不使用自增主键

1. 只有一个索引
2. 该索引必须是唯一索引

###### mysql索引使用原则

**<u>最左前缀原则</u>**：

不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左 前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符

建立索引原则：

1. 经有了(a,b)这个联 合索引后，一般就不需要单独在a上建立索引了

**<u>索引下推原则</u>**：

如果建立了(name,age)索引，在select时候就会先判断name，从name中判断age，在进行回表操作

###### 前缀索引（字符串索引存储方式）

前缀索引可能会遇到区分度不太够的情况，这个时候可以选择**倒序存储**，**使用hash字段**，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的 方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样 地，hash字段的方式也只能支持等值查询。

它们的区别，主要体现在以下三个方面： 

1. 从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字 段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如 果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。
2. 在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash 字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的 话，reverse函数额外消耗的CPU资源会更小些。
3.  从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽 然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储 方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数
