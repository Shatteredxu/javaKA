### 设计模式六大原则

1.单一职责原则

2.开闭原则

3.里氏替换原则

4.迪米特法则原则

5.接口隔离原则

6.依赖倒置原则



| 创建型模式    | 结构型模式      | 行为型模式       |
| ------------- | --------------- | ---------------- |
| 工厂方法模式√ | **适配器模式**  | **策略模式**√    |
| 抽象工厂模式√ | **装饰器模式**√ | **模板方法模式** |
| **单例模式**√ | **代理模式**    | **观察者模式**   |
| 建造者模式    | 桥接模式        | 迭代器模式       |
| 原型模式      | 组合模式        | **责任链模式**   |
|               | 享元模式        | 行为型模式       |

```
设计原则：开闭原则
单一职责原则
里氏替换原则
依赖倒置原则
接口隔离原则
迪米特法则
合成复用原则
```

### 单例模式

创建型：懒汉式，饿汉式，DCL,枚举，静态内部类

### 工厂模式

如果你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 `卡车`的类中，现在你需要开发其他物流方式，比如海上物流等，这时我们应该要怎么处理呢？我们只能将卡车代码进行全部复制，修改，或者对卡车类中的代码进行修改，所以就引入了**工厂模式**

工厂模式有：产品接口类，具体产品类，创建者接口类（定义一些公用的操作，子类可以重写），具体创建者类（返回具体的一个产品对象）

适用场景：



### 策略模式

##### 策略模式的优点

　　（1）策略模式提供了**管理相关的算法族的办法**。策略类的等级结构定义了一个算法或行为族。恰当**使用继承可以把公共的代码移到父类里面，从而避免代码重复**。

　　（2）使用策略模式可以避免使用**多重条件(if-else)语句**。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。

##### 策略模式的缺点

　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，**策略模式只适用于客户端知道算法或行为的情况**。

　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。

### 责任链模式

