java基础知识
------------

[TOC]



##### **JDK 和 JRE 有什么区别？**

JDK：Java开发运行环境，拥有了运 行Java程序的平台。JDK是整个Java的核心，包括了Java运行环境(JRE)，一堆Java工具tools.jar和Java标准类库 (rt.jar)。

JRE:JVM标准实现及 Java核心类库。它包括Java虚拟机、Java平台核心类和支持文件。它不包含开发工具(编译器、调试器等

##### **== 和 equals 的区别是什么？**

*==:* 基本类型：比较的是值是否相同；引用类型：比较的是引用是否相同

**equals():**原来就是用==比较，只不过Integer和String对equals进行了重写，会去比较值是否相等

总结：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。

##### **两个对象的 hashCode相同，则 equals也一定为 true**

两个对象equals相等，则它们的hashcode必须相等，反之则不一定。
		两个对象==相等，则其hashcode一定相等，反之不一定成立。

hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。

hashcode相等，但是对象可能不等，所以还需要用equals判断

对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置,看该位置是否有值，如果没
有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals ()方法来检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。

**##### final ，static在 java 中有什么作用？**

首先final可以修饰引用，方法，类

**修饰引用：**

1. 如果引用为基本数据类型，则该引用为常量，该值无法修改；

2. 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。
3. 如果引用时类的成员变量，则必须当场赋值，否则编译会报错。

修饰方法不能被子类重写

修饰类，不能被继承，比如String

然后static可以修饰成员变量，成员方法，代码块、

1. 用static关键字修饰的静态变量和不用static关键字修饰的实例变量。

2. static方法是类的方法，不需要创建对象就可以被调用，而非static方法是对象的方法，只有对象被创建出来后才可以被使用

3. static代码块在类中是独立于成员变量和成员函数的代码块的。注意： 这些static代码块只会被执行一次

##### String str="i"与 String str=new String(“i”)一样吗？

细读：https://www.cnblogs.com/xiaoxi/p/6036701.html

##### StringBuffer和Stringbuilder

StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且***\*不产生新的未使用对象\****。

 StringBuilder 的方法不是线程安全的（不能同步访问）。

由StringBuilder 速度比 StringBuffer 快

 

##### 抽象类和接口的区别

含有abstract修饰符的class即为抽象类，abstract 类不能创建实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract 类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。

接口（interface）可以说成是抽象类的一种特例，<u>接口中的所有方法都必须是抽象的</u>。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final1.抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现    		1.所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。

2、抽象类要被子类继承，接口要被类实现。

3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现

4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。

5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。

6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果

7、抽象类里可以没有抽象方法

8、如果一个类里有抽象方法，那么这个类只能是抽象类

9、抽象方法要被实现，所以不能是静态的，也不能是私有的。

10、接口可继承接口，并可多继承接口，但类只能单根继承

##### 普通类和抽象类有哪些区别？

· 抽象类不能被实例化

· 抽象类可以有抽象方法，抽象方法只需申明，无需实现

· 含有抽象方法的类必须申明为抽象类

· 抽象的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类

· 抽象方法不能被声明为静态

· 抽象方法不能用private修饰

· 抽象方法不能用final修饰

 



 

##### BIO、NIO、AIO 有什么区别？

同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO

##### 容器都有哪些？



#####  Collection 和 Collections 有什么区别？

##### 21.HashMap 和 Hashtable 有什么区别？

##### 22.如何决定使用 HashMap 还是 TreeMap？

##### 23.说一下 HashMap 的实现原理？

##### 24.说一下 HashSet 的实现原理？

##### 25.ArrayList 和 LinkedList 的区别是什么？

##### 26.如何实现数组和 List 之间的转换？

##### 27.ArrayList 和 Vector 的区别是什么？

##### 28.Array 和 ArrayList 有何区别？

##### 29.在 Queue 中 poll()和 remove()有什么区别？

##### 30.哪些集合类是线程安全的？

##### 31.迭代器 Iterator 是什么？

##### 32.Iterator 怎么使用？有什么特点？

##### 33.Iterator 和 ListIterator 有什么区别？

##### 34.怎么确保一个集合不能被修改？

final关键字可以修饰类，方法，成员变量，final修饰的类不能被继承，final修饰的方法不能被重写，final修饰的成员变量必须初始化值，如果这个成员变量是基本数据类型，表示这个变量的值是不可改变的，如果说这个成员变量是引用类型，则表示这个引用的地址值是不能改变的，但是这个引用所指向的对象里面的内容还是可以改变的

那么，我们怎么确保一个集合不能被修改？首先我们要清楚，集合（map,set,list…）都是引用类型，所以我们如果用final修饰的话，集合里面的内容还是可以修改的。

假如我们用final关键字定义了一个map集合，这时候我们往集合里面传值，第一个键值对1,1；我们再修改后，可以把键为1的值改为100，说明我们是可以修改map集合的值的。

那我们应该怎么做才能确保集合不被修改呢？
我们可以采用Collections包下的unmodifiableMap方法，通过这个方法返回的map,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。

同理：Collections包也提供了对list和set集合的方法。
Collections.unmodifiableList(List)
Collections.unmodifiableSet(Set)